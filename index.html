<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root {
    --bg-main: #071a33;
    --bg-card: #0d2342;
    --bg-card-soft: #122a4c;
    --accent-green: #18c37a;
    --accent-orange: #ff9f1c;
    --accent-red: #ff3b30;
    --accent-blue: #1e90ff;
    --text-main: #f5f7ff;
    --text-soft: #c3c8e4;
    --border-soft: #1e345a;
    --good: #18c37a;
    --bad: #ff3b30;
    --warn: #ffd166;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  body {
    background: radial-gradient(circle at top, #10284f, #050b19);
    color: var(--text-main);
    padding: 0;
    margin: 0;
  }

  .page {
    max-width: 1200px;
    margin: 0 auto;
    padding-bottom: 48px;
  }

  /* Top sticky bar with logo */
  .top-bar {
    position: sticky;
    top: 0;
    z-index: 50;
    background: rgba(5, 11, 25, 0.98);
    border-bottom: 1px solid #1c3154;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .logo-circle {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 3px solid #ffffff;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at 30% 30%, #ffffff, #d3e2ff);
    overflow: hidden;
  }

  .logo-gear {
    position: absolute;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    border: 3px solid #0d2342;
    box-shadow: inset 0 0 0 3px #ffffff;
  }

  .logo-gear::before,
  .logo-gear::after {
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    width: 2px;
    height: 12px;
    background: #ff3b30;
    transform-origin: bottom center;
    border-radius: 999px;
  }

  .logo-gear::before {
    transform: translate(-50%, -100%) rotate(20deg);
  }

  .logo-gear::after {
    height: 5px;
    transform: translate(-50%, -100%) rotate(-70deg);
    background: #071a33;
  }

  .logo-ring {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 4px solid transparent;
    border-top-color: var(--accent-green);
    border-right-color: var(--accent-green);
    border-bottom-color: #cccccc;
    border-left-color: #cccccc;
    animation: logoSpin 3.2s linear infinite;
  }

  @keyframes logoSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .logo-title {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .logo-title h1 {
    font-size: 1.15rem;
    letter-spacing: 0.06em;
  }

  .logo-title span {
    font-size: 0.75rem;
    color: var(--text-soft);
  }

  /* Sticky stopwatch + control bar */
  .sticky-panel {
    position: sticky;
    top: 58px; /* below top-bar */
    z-index: 40;
    padding: 8px 12px 0;
    background: linear-gradient(to bottom, rgba(5, 11, 25, 0.98), rgba(5, 11, 25, 0.9));
  }

  .stopwatch-card {
    background: var(--bg-card);
    border-radius: 18px;
    padding: 12px 12px 16px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.45);
  }

  .stopwatch-display {
    width: 100%;
    background: #020817;
    border-radius: 16px;
    padding: 16px 18px;
    text-align: center;
    font-size: 2.5rem;
    letter-spacing: 0.12em;
    margin-bottom: 10px;
    border: 1px solid #1a2f55;
  }

  .stopwatch-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .btn {
    border: none;
    border-radius: 16px;
    padding: 10px 14px;
    font-size: 1.05rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
  }

  .btn:active {
    transform: translateY(1px) scale(0.99);
    box-shadow: none;
  }

  .btn-primary {
    background: var(--accent-green);
    color: #041019;
    box-shadow: 0 4px 12px rgba(24, 195, 122, 0.4);
  }

  .btn-accent {
    background: var(--accent-orange);
    color: #3c2100;
    box-shadow: 0 4px 12px rgba(255, 159, 28, 0.4);
  }

  .btn-ghost {
    background: #2a3550;
    color: var(--text-soft);
    box-shadow: 0 2px 6px rgba(0,0,0,0.35);
  }

  .btn-danger {
    background: #3b1a1f;
    color: #ffb4c0;
  }

  .btn-small {
    font-size: 0.8rem;
    padding: 8px 10px;
    border-radius: 10px;
  }

  .inputs-row {
    margin-top: 10px;
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
  }

  .inputs-row-4 {
    margin-top: 8px;
    display: grid;
    grid-template-columns: repeat(4, minmax(0,1fr));
    gap: 6px;
  }

  @media (max-width: 600px) {
    .inputs-row-4 {
      grid-template-columns: repeat(2, minmax(0,1fr));
    }
  }

  .field {
    display: flex;
    flex-direction: column;
    gap: 2px;
    font-size: 0.72rem;
  }

  .field label {
    color: var(--text-soft);
  }

  .field input,
  .field select {
    border-radius: 10px;
    border: 1px solid var(--border-soft);
    padding: 4px 6px;
    background: var(--bg-card-soft);
    color: var(--text-main);
    font-size: 0.78rem;
  }

  .field input:focus,
  .field select:focus {
    outline: 1px solid var(--accent-blue);
  }

  .mode-badges {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    align-items: center;
    flex-wrap: wrap;
  }

  .badge {
    font-size: 0.68rem;
    padding: 4px 7px;
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    background: #0c213d;
    color: var(--text-soft);
  }

  .badge-ml {
    border-color: var(--accent-orange);
    color: var(--accent-orange);
  }

  /* T1/T2 indicator */
  .t-indicator-wrap {
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
    margin-top: 10px;
  }

  .t-indicator {
    position: relative;
    height: 54px;
    border-radius: 12px;
    background: #050d1e;
    border: 1px solid #1b294b;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .t-indicator .ring {
    position: absolute;
    width: 54px;
    height: 54px;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #4ade80;
    border-right-color: #4ade80;
    border-bottom-color: #1f2937;
    border-left-color: #1f2937;
    opacity: 0.15;
  }

  .t-indicator.active .ring {
    opacity: 0.9;
    animation: spinT 1.2s linear infinite;
  }

  @keyframes spinT {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .t-indicator .label {
    position: relative;
    font-size: 0.72rem;
    color: var(--text-soft);
    text-align: center;
  }

  .t-indicator .label span {
    display: block;
  }

  .t-indicator .label strong {
    font-size: 0.78rem;
  }

  .t-indicator.waiting .label {
    opacity: 0.5;
  }

  /* Main content cards */
  .cards {
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .card {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 10px 10px 12px;
    border: 1px solid #152749;
    box-shadow: 0 12px 24px rgba(0,0,0,0.45);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .card-header h2 {
    font-size: 0.95rem;
    font-weight: 600;
  }

  .card-header small {
    color: var(--text-soft);
    font-size: 0.72rem;
  }

  /* Tables */
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
  }

  thead {
    background: #111f3d;
  }

  th, td {
    padding: 4px 6px;
    text-align: center;
    border-bottom: 1px solid #1a2947;
  }

  th {
    font-weight: 600;
    color: var(--text-soft);
    position: sticky;
    top: 0;
    background: #111f3d;
    z-index: 5;
  }

  tbody tr:nth-child(even) {
    background: #0d1c37;
  }

  tbody tr:nth-child(odd) {
    background: #091427;
  }

  tbody tr.highlight {
    background: rgba(24, 195, 122, 0.2);
  }

  td input, td select {
    width: 100%;
    border-radius: 8px;
    border: 1px solid #273453;
    padding: 2px 4px;
    background: #050d1c;
    color: var(--text-main);
    font-size: 0.7rem;
  }

  .tag-good {
    color: var(--good);
  }

  .tag-bad {
    color: var(--bad);
  }

  .tag-warn {
    color: var(--warn);
  }

  .btn-del {
    background: #3c1a21;
    border-radius: 999px;
    padding: 2px 6px;
    font-size: 0.7rem;
    cursor: pointer;
    border: none;
    color: #ffb3c1;
  }

  /* Copy buttons area */
  .copy-row {
    margin-top: 6px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }

  .copy-row .btn {
    min-width: 120px;
  }

  /* Pills */
  .pill {
    border-radius: 999px;
    padding: 3px 8px;
    font-size: 0.7rem;
    border: 1px solid #273453;
    color: var(--text-soft);
  }

  .pill-ok {
    border-color: var(--good);
    color: var(--good);
  }

  .pill-bad {
    border-color: var(--bad);
    color: var(--bad);
  }

  canvas {
    width: 100%;
    max-height: 220px;
    background: #050c1a;
    border-radius: 12px;
    border: 1px solid #172748;
    margin-top: 8px;
  }

  .footer-note {
    margin-top: 8px;
    text-align: right;
    font-size: 0.6rem;
    color: #6f7ca5;
  }
</style>
</head>
<body>
<div class="page">
  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="logo-circle">
      <div class="logo-gear"></div>
      <div class="logo-ring"></div>
    </div>
    <div class="logo-title">
      <h1>TaktLab</h1>
      <span>Cycle Time &amp; Capacity Analyzer</span>
    </div>
  </div>

  <!-- STICKY STOPWATCH & CONTROLS -->
  <div class="sticky-panel">
    <div class="stopwatch-card">
      <div id="stopwatchDisplay" class="stopwatch-display">00:00.00</div>
      <div class="stopwatch-grid">
        <button id="startPauseBtn" class="btn btn-primary">Start</button>
        <button id="lapBtn" class="btn btn-accent">LAP</button>
      </div>

      <div class="inputs-row">
        <div class="field">
          <label for="processInput">Process / Operation</label>
          <input id="processInput" type="text" placeholder="Op 30-1" />
        </div>
        <div class="field">
          <label for="modeSelect">Mode</label>
          <select id="modeSelect">
            <option value="cycle">Cycle Time</option>
            <option value="ml">Machine &amp; Load/Unload Time</option>
          </select>
        </div>
      </div>

      <div class="inputs-row-4">
        <div class="field">
          <label for="contractPcd">Contract pieces/day</label>
          <input id="contractPcd" type="number" min="0" step="1" placeholder="1200" />
        </div>
        <div class="field">
          <label for="hoursPerDay">Hours per day</label>
          <input id="hoursPerDay" type="number" min="1" max="24" step="0.5" value="8" />
        </div>
        <div class="field">
          <label for="daysPerWeek">Days per week</label>
          <input id="daysPerWeek" type="number" min="1" max="7" value="5" />
        </div>
        <div class="field">
          <label for="efficiency">Efficiency %</label>
          <input id="efficiency" type="number" min="50" max="110" value="100" />
        </div>
      </div>

      <div class="mode-badges">
        <span class="badge">CT from total cycle time</span>
        <span class="badge badge-ml">M+L/D keeps T1 + T2 separated</span>
      </div>

      <div class="t-indicator-wrap">
        <div id="t1Indicator" class="t-indicator waiting">
          <div class="ring"></div>
          <div class="label">
            <span>T1 – Machine</span>
            <strong id="t1Live">waiting…</strong>
          </div>
        </div>
        <div id="t2Indicator" class="t-indicator waiting">
          <div class="ring"></div>
          <div class="label">
            <span>T2 – Load/Unload</span>
            <strong id="t2Live">idle</strong>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- MAIN CARDS -->
  <div class="cards">
    <!-- PROCESS SUMMARY TABLE + STATS -->
    <div class="card">
      <div class="card-header">
        <h2>Process Capacity Overview</h2>
        <small>Median CT, capacity and % vs contract per process</small>
      </div>

      <div style="overflow-x:auto; max-height:260px;">
        <table id="summaryTable">
          <thead>
            <tr>
              <th>Proc</th>
              <th>Mode</th>
              <th>N</th>
              <th>CTmed (s)</th>
              <th>Cap 100% (pph)</th>
              <th>Cap @Eff% (pph)</th>
              <th>% vs contract</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <!-- Selector + Cp/Cpk & percentiles justo debajo -->
      <div class="field" style="margin-top:6px;">
        <label for="statsProcessSelect">Stats focus (Cp/Cpk &amp; percentiles)</label>
        <select id="statsProcessSelect"></select>
      </div>
      <div id="capabilitySummary" style="margin-top:4px; font-size:0.74rem; color:var(--text-soft);">
        Select a process to see Cp/Cpk, percentiles and N.
      </div>

      <div class="copy-row">
        <button id="copyAllBtn" class="btn btn-ghost btn-small">Copy All</button>
        <button id="copySummaryBtn" class="btn btn-ghost btn-small">Copy Summary</button>
        <button id="addManualBtn" class="btn btn-ghost btn-small">Add Manual Lap</button>
        <button id="resetBtn" class="btn btn-danger btn-small">Reset</button>
      </div>
    </div>

    <!-- LAPS TABLE -->
    <div class="card">
      <div class="card-header">
        <h2>Raw Cycle-Time Data</h2>
        <small>#, status, notes, T1/T2 &amp; total per lap</small>
      </div>
      <div style="overflow-x:auto; max-height:360px;">
        <table id="lapsTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Process</th>
              <th>Mode</th>
              <th>Status</th>
              <th>Note</th>
              <th>T1 (s)</th>
              <th>T2 (s)</th>
              <th>Total (s)</th>
              <th>Del</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- CAPABILITY & GRAPHS (visual only) -->
    <div class="card">
      <div class="card-header">
        <h2>Distribution & Capability Plots</h2>
        <small>Visual support for the stats above</small>
      </div>
      <div class="field" style="margin-bottom:6px;">
        <label for="graphProcessSelect">Graph focus</label>
        <select id="graphProcessSelect"></select>
      </div>
      <canvas id="histCanvas"></canvas>
      <canvas id="xbarCanvas"></canvas>
      <canvas id="capCanvas"></canvas>
    </div>

    <!-- CONTRACT vs CAPACITY SUMMARY AS TABLE -->
    <div class="card">
      <div class="card-header">
        <h2>Contract vs Capacity Summary</h2>
        <small>Median CT, capacity @Eff and verdict vs contract</small>
      </div>
      <div style="overflow-x:auto; max-height:260px;">
        <table id="complianceTable">
          <thead>
            <tr>
              <th>Process</th>
              <th>Mode</th>
              <th>CTmed (s)</th>
              <th>Cap @Eff (pph)</th>
              <th>% vs contract</th>
              <th>Verdict</th>
            </tr>
          </thead>
          <tbody id="complianceBody"></tbody>
        </table>
      </div>
    </div>

    <div class="footer-note">
      Created by Roberto González
    </div>
  </div>
</div>

<script>
  // --- Stopwatch core state ---
  let startTime = null;
  let elapsedBeforePause = 0;
  let timerInterval = null;
  let isRunning = false;
  let lastSegStart = null;
  let lapPhase = "T1"; // for M+L/D
  let tempT1 = null;

  // DOM references
  const displayEl = document.getElementById("stopwatchDisplay");
  const startPauseBtn = document.getElementById("startPauseBtn");
  const lapBtn = document.getElementById("lapBtn");
  const processInput = document.getElementById("processInput");
  const modeSelect = document.getElementById("modeSelect");
  const lapsTableBody = document.querySelector("#lapsTable tbody");
  const summaryTableBody = document.querySelector("#summaryTable tbody");
  const graphProcessSelect = document.getElementById("graphProcessSelect");
  const statsProcessSelect = document.getElementById("statsProcessSelect");
  const contractPcdInput = document.getElementById("contractPcd");
  const hoursPerDayInput = document.getElementById("hoursPerDay");
  const daysPerWeekInput = document.getElementById("daysPerWeek");
  const efficiencyInput = document.getElementById("efficiency");
  const t1Indicator = document.getElementById("t1Indicator");
  const t2Indicator = document.getElementById("t2Indicator");
  const t1Live = document.getElementById("t1Live");
  const t2Live = document.getElementById("t2Live");
  const copyAllBtn = document.getElementById("copyAllBtn");
  const copySummaryBtn = document.getElementById("copySummaryBtn");
  const addManualBtn = document.getElementById("addManualBtn");
  const resetBtn = document.getElementById("resetBtn");
  const capabilitySummary = document.getElementById("capabilitySummary");
  const complianceBody = document.getElementById("complianceBody");

  const histCanvas = document.getElementById("histCanvas");
  const xbarCanvas = document.getElementById("xbarCanvas");
  const capCanvas = document.getElementById("capCanvas");

  let laps = [];
  let lapCounter = 0;

  function formatTime(ms) {
    if (ms < 0) ms = 0;
    const totalSec = ms / 1000;
    const min = Math.floor(totalSec / 60);
    const sec = (totalSec % 60).toFixed(2);
    const minStr = min.toString().padStart(2, "0");
    const secStr = sec.toString().padStart(5, "0");
    return `${minStr}:${secStr}`;
  }

  function updateDisplay() {
    if (!isRunning || startTime === null) return;
    const now = Date.now();
    const elapsed = now - startTime + elapsedBeforePause;
    displayEl.textContent = formatTime(elapsed);

    // live T1/T2 short feedback when in M+L mode
    if (modeSelect.value === "ml" && lastSegStart !== null) {
      const segElapsed = now - lastSegStart;
      const value = (segElapsed / 1000).toFixed(1);
      if (lapPhase === "T1") {
        t1Live.textContent = value + " s";
      } else {
        t2Live.textContent = value + " s";
      }
    }
  }

  function startTimer() {
    if (isRunning) return;
    startTime = Date.now();
    lastSegStart = Date.now();
    elapsedBeforePause = 0;
    isRunning = true;
    startPauseBtn.textContent = "Pause";
    lapPhase = "T1";
    tempT1 = null;
    setIndicators();
    timerInterval = setInterval(updateDisplay, 50);
  }

  function resumeTimer() {
    if (isRunning) return;
    startTime = Date.now();
    lastSegStart = Date.now();
    isRunning = true;
    startPauseBtn.textContent = "Pause";
    setIndicators();
    timerInterval = setInterval(updateDisplay, 50);
  }

  function pauseTimer() {
    if (!isRunning) return;
    clearInterval(timerInterval);
    isRunning = false;
    startPauseBtn.textContent = "Start";
    elapsedBeforePause = 0;
    lastSegStart = null;
    // detener el giro de los aros
    t1Indicator.classList.remove("active");
    t2Indicator.classList.remove("active");
    t1Indicator.classList.add("waiting");
    t2Indicator.classList.add("waiting");
  }

  function resetTimerState() {
    clearInterval(timerInterval);
    isRunning = false;
    startTime = null;
    elapsedBeforePause = 0;
    lastSegStart = null;
    lapPhase = "T1";
    tempT1 = null;
    displayEl.textContent = "00:00.00";
    startPauseBtn.textContent = "Start";
    t1Live.textContent = "waiting…";
    t2Live.textContent = "idle";
    t1Indicator.classList.add("waiting");
    t1Indicator.classList.remove("active");
    t2Indicator.classList.add("waiting");
    t2Indicator.classList.remove("active");
  }

  function setIndicators() {
    if (!isRunning || modeSelect.value !== "ml") {
      t1Indicator.classList.add("waiting");
      t1Indicator.classList.remove("active");
      t2Indicator.classList.add("waiting");
      t2Indicator.classList.remove("active");
      if (!isRunning) return;
    }
    if (modeSelect.value !== "ml") {
      t1Live.textContent = "n/a";
      t2Live.textContent = "n/a";
      return;
    }
    if (lapPhase === "T1") {
      t1Indicator.classList.add("active");
      t1Indicator.classList.remove("waiting");
      t2Indicator.classList.add("waiting");
      t2Indicator.classList.remove("active");
    } else {
      t2Indicator.classList.add("active");
      t2Indicator.classList.remove("waiting");
      t1Indicator.classList.add("waiting");
      t1Indicator.classList.remove("active");
    }
  }

  startPauseBtn.addEventListener("click", () => {
    if (!isRunning && startTime === null) {
      startTimer();
    } else if (!isRunning && startTime !== null) {
      resumeTimer();
    } else {
      pauseTimer();
    }
  });

  function addLapRow(process, mode, t1, t2, total) {
    lapCounter += 1;
    const row = {
      id: lapCounter,
      process,
      mode,
      status: "",
      note: "",
      t1,
      t2,
      total
    };
    laps.push(row);
    renderLapsTable();
    recomputeAll();
  }

  lapBtn.addEventListener("click", () => {
    if (!isRunning || lastSegStart === null) return;
    const now = Date.now();
    let segMs = now - lastSegStart;
    if (segMs < 150) return; // evitar fantasmas
    lastSegStart = now;
    const segSec = segMs / 1000;

    const process = (processInput.value || "").trim() || "Process";
    const mode = modeSelect.value;

    if (mode === "cycle") {
      addLapRow(process, "CT", round1(segSec), null, round1(segSec));
    } else {
      if (lapPhase === "T1") {
        tempT1 = segSec;
        lapPhase = "T2";
        setIndicators();
        t1Live.textContent = round1(segSec) + " s";
      } else {
        const t1 = tempT1 != null ? tempT1 : 0;
        const t2 = segSec;
        const total = t1 + t2;
        addLapRow(process, "M+L/D", round1(t1), round1(t2), round1(total));
        tempT1 = null;
        lapPhase = "T1";
        setIndicators();
        t2Live.textContent = round1(segSec) + " s";
      }
    }
    startTime = Date.now();
    elapsedBeforePause = 0;
    displayEl.textContent = "00:00.00";
  });

  function round1(v) {
    return Math.round(v * 10) / 10;
  }

  function renderLapsTable() {
    lapsTableBody.innerHTML = "";
    laps.forEach((lap, idx) => {
      const tr = document.createElement("tr");

      const tdIndex = document.createElement("td");
      tdIndex.textContent = idx + 1;
      tr.appendChild(tdIndex);

      const tdProc = document.createElement("td");
      const procInput = document.createElement("input");
      procInput.value = lap.process;
      procInput.addEventListener("change", () => {
        lap.process = procInput.value.trim();
        recomputeAll();
      });
      tdProc.appendChild(procInput);
      tr.appendChild(tdProc);

      const tdMode = document.createElement("td");
      const modeInput = document.createElement("select");
      ["CT", "M+L/D"].forEach(m => {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        if (lap.mode === m) opt.selected = true;
        modeInput.appendChild(opt);
      });
      modeInput.addEventListener("change", () => {
        lap.mode = modeInput.value;
        recomputeAll();
      });
      tdMode.appendChild(modeInput);
      tr.appendChild(tdMode);

      const tdStatus = document.createElement("td");
      const statusInput = document.createElement("select");
      ["", "Starving", "Blocked"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        if (lap.status === s) opt.selected = true;
        statusInput.appendChild(opt);
      });
      statusInput.addEventListener("change", () => {
        lap.status = statusInput.value;
      });
      tdStatus.appendChild(statusInput);
      tr.appendChild(tdStatus);

      const tdNote = document.createElement("td");
      const noteInput = document.createElement("input");
      noteInput.value = lap.note;
      noteInput.addEventListener("change", () => {
        lap.note = noteInput.value;
      });
      tdNote.appendChild(noteInput);
      tr.appendChild(tdNote);

      const tdT1 = document.createElement("td");
      const t1Input = document.createElement("input");
      t1Input.type = "number";
      t1Input.step = "0.1";
      t1Input.value = lap.t1 != null ? lap.t1 : "";
      t1Input.addEventListener("change", () => {
        lap.t1 = t1Input.value ? parseFloat(t1Input.value) : null;
        if (lap.mode === "CT") {
          lap.total = lap.t1 || 0;
        } else {
          lap.total = (lap.t1 || 0) + (lap.t2 || 0);
        }
        recomputeAll();
      });
      tdT1.appendChild(t1Input);
      tr.appendChild(tdT1);

      const tdT2 = document.createElement("td");
      const t2Input = document.createElement("input");
      t2Input.type = "number";
      t2Input.step = "0.1";
      t2Input.value = lap.t2 != null ? lap.t2 : "";
      t2Input.addEventListener("change", () => {
        lap.t2 = t2Input.value ? parseFloat(t2Input.value) : null;
        if (lap.mode === "CT") {
          lap.total = lap.t1 || 0;
        } else {
          lap.total = (lap.t1 || 0) + (lap.t2 || 0);
        }
        recomputeAll();
      });
      tdT2.appendChild(t2Input);
      tr.appendChild(tdT2);

      const tdTotal = document.createElement("td");
      const totalInput = document.createElement("input");
      totalInput.type = "number";
      totalInput.step = "0.1";
      totalInput.value = lap.total != null ? lap.total : "";
      totalInput.addEventListener("change", () => {
        lap.total = totalInput.value ? parseFloat(totalInput.value) : null;
        recomputeAll();
      });
      tdTotal.appendChild(totalInput);
      tr.appendChild(tdTotal);

      const tdDel = document.createElement("td");
      const delBtn = document.createElement("button");
      delBtn.className = "btn-del";
      delBtn.textContent = "X";
      delBtn.addEventListener("click", () => {
        laps = laps.filter(l => l.id !== lap.id);
        renderLapsTable();
        recomputeAll();
      });
      tdDel.appendChild(delBtn);
      tr.appendChild(tdDel);

      lapsTableBody.appendChild(tr);
    });
  }

  // --- Stats and capacity ---
  function recomputeAll() {
    recomputeSummary();
    updateProcessSelectors();
    updateGraphsAndCapability(); // usa el selector de graph
    updateComplianceSummary();
  }

  function median(arr) {
    if (!arr.length) return null;
    const sorted = [...arr].sort((a,b)=>a-b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid-1] + sorted[mid]) / 2;
    } else {
      return sorted[mid];
    }
  }

  function mean(arr) {
    if (!arr.length) return null;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }

  function stdDev(arr) {
    if (arr.length < 2) return null;
    const m = mean(arr);
    const variance = arr.reduce((acc,v)=> acc + Math.pow(v-m,2), 0) / (arr.length - 1);
    return Math.sqrt(variance);
  }

  function recomputeSummary() {
    summaryTableBody.innerHTML = "";

    // group by process + mode, but do not mix CT vs M+L
    const groups = {};
    laps.forEach(lap => {
      if (lap.total == null || lap.total <= 0) return;
      const key = lap.process + "||" + lap.mode;
      if (!groups[key]) groups[key] = [];
      groups[key].push(lap.total);
    });

    const contractPcd = parseFloat(contractPcdInput.value) || null;
    const hoursPerDay = Math.min(Math.max(parseFloat(hoursPerDayInput.value) || 8,1),24);
    const daysPerWeek = Math.min(Math.max(parseFloat(daysPerWeekInput.value) || 5,1),7);
    const eff = parseFloat(efficiencyInput.value) || 100;
    const effFactor = eff / 100;

    const contractPerHour = contractPcd && hoursPerDay ? (contractPcd / hoursPerDay) : null;

    Object.keys(groups).forEach(key => {
      const [proc, mode] = key.split("||");
      const arr = groups[key];
      const N = arr.length;
      const med = median(arr);
      const cap100 = med ? 3600 / med : null; // pieces/hour
      const capEff = cap100 != null ? cap100 * effFactor : null;
      let vsContract = null;
      if (contractPerHour && capEff != null) {
        vsContract = (capEff / contractPerHour) * 100;
      }

      const tr = document.createElement("tr");

      const tdProc = document.createElement("td");
      tdProc.textContent = proc;
      tr.appendChild(tdProc);

      const tdMode = document.createElement("td");
      tdMode.textContent = mode;
      tr.appendChild(tdMode);

      const tdN = document.createElement("td");
      tdN.textContent = N;
      tr.appendChild(tdN);

      const tdMed = document.createElement("td");
      tdMed.textContent = med ? med.toFixed(1) : "-";
      tr.appendChild(tdMed);

      const tdCap100 = document.createElement("td");
      tdCap100.textContent = cap100 ? cap100.toFixed(1) : "-";
      tr.appendChild(tdCap100);

      const tdCapEff = document.createElement("td");
      tdCapEff.textContent = capEff ? capEff.toFixed(1) : "-";
      tr.appendChild(tdCapEff);

      const tdVs = document.createElement("td");
      if (vsContract != null) {
        const pct = vsContract.toFixed(0) + "%";
        tdVs.textContent = pct;
        if (vsContract > 105) {
          tdVs.classList.add("tag-good");
        } else if (vsContract >= 85 && vsContract <= 105) {
          tdVs.classList.add("tag-warn");
        } else {
          tdVs.classList.add("tag-bad");
        }
      } else {
        tdVs.textContent = "-";
      }
      tr.appendChild(tdVs);

      summaryTableBody.appendChild(tr);
    });
  }

  function updateProcessSelectors() {
    const keys = new Set();
    laps.forEach(l => {
      if (l.total && l.total > 0) {
        keys.add(l.process + "||" + l.mode);
      }
    });

    const prevGraph = graphProcessSelect.value;
    const prevStats = statsProcessSelect.value;

    graphProcessSelect.innerHTML = "";
    statsProcessSelect.innerHTML = "";

    keys.forEach(k => {
      const [proc, mode] = k.split("||");
      const label = proc + " (" + mode + ")";
      const opt1 = document.createElement("option");
      opt1.value = k;
      opt1.textContent = label;
      graphProcessSelect.appendChild(opt1);

      const opt2 = document.createElement("option");
      opt2.value = k;
      opt2.textContent = label;
      statsProcessSelect.appendChild(opt2);
    });

    if (graphProcessSelect.options.length) {
      const foundG = Array.from(graphProcessSelect.options).some(o => o.value === prevGraph);
      if (foundG) graphProcessSelect.value = prevGraph;
    }

    if (statsProcessSelect.options.length) {
      const foundS = Array.from(statsProcessSelect.options).some(o => o.value === prevStats);
      if (foundS) statsProcessSelect.value = prevStats;
    }

    updateStatsPanel();
  }

  statsProcessSelect.addEventListener("change", updateStatsPanel);

  function getProcessDataByKey(key) {
    if (!key) return [];
    return laps.filter(l => (l.process + "||" + l.mode) === key && l.total && l.total > 0)
               .map(l => l.total);
  }

  function updateStatsPanel() {
    const key = statsProcessSelect.value;
    if (!key) {
      capabilitySummary.textContent = "Select a process to see Cp/Cpk, percentiles and N.";
      return;
    }
    const data = getProcessDataByKey(key);
    if (!data.length) {
      capabilitySummary.textContent = "No valid data for this process yet.";
      return;
    }

    const sorted = [...data].sort((a,b)=>a-b);
    const N = sorted.length;
    const meanVal = mean(sorted);
    const medVal = median(sorted);
    const std = stdDev(sorted) || 0.0001;
    const p10 = sorted[Math.floor(0.10*(N-1))];
    const p25 = sorted[Math.floor(0.25*(N-1))];
    const p50 = medVal;
    const p75 = sorted[Math.floor(0.75*(N-1))];
    const p90 = sorted[Math.floor(0.90*(N-1))];

    // simple Cp/Cpk usando LSL = 0 y USL = 1.1*mediana (target interno)
    const LSL = 0;
    const USL = medVal * 1.1;
    const cp = (USL - LSL) / (6 * (std || 0.0001));
    const cpk = Math.min(
      (USL - meanVal)/(3*std || 0.0001),
      (meanVal-LSL)/(3*std || 0.0001)
    );

    let verdict;
    if (cp >= 1.33 && cpk >= 1.33) {
      verdict = "Process capable vs internal target.";
    } else if (cp >= 1.0 && cpk >= 1.0) {
      verdict = "Borderline capable – keep improving.";
    } else {
      verdict = "Process currently not capable – focus here.";
    }

    capabilitySummary.innerHTML =
      `<span><strong>N:</strong> ${N}</span><br/>
       <span><strong>Mean / Median:</strong> ${meanVal.toFixed(2)} s / ${medVal.toFixed(2)} s</span><br/>
       <span><strong>P10 / P25 / P50 / P75 / P90:</strong> ${p10.toFixed(2)} / ${p25.toFixed(2)} / ${p50.toFixed(2)} / ${p75.toFixed(2)} / ${p90.toFixed(2)} s</span><br/>
       <span><strong>Cp:</strong> ${cp.toFixed(2)} | <strong>Cpk:</strong> ${cpk.toFixed(2)}</span><br/>
       <span>${verdict}</span>`;
  }

  graphProcessSelect.addEventListener("change", () => {
    updateGraphsAndCapability();
  });

  function clearCanvas(canvas) {
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function updateGraphsAndCapability() {
    const key = graphProcessSelect.value;
    const data = getProcessDataByKey(key);
    clearCanvas(histCanvas);
    clearCanvas(xbarCanvas);
    clearCanvas(capCanvas);

    if (!data.length) return;

    // histogram
    const ctxH = histCanvas.getContext("2d");
    const w = histCanvas.width;
    const h = histCanvas.height;
    const binsCount = Math.min(10, Math.max(5, Math.round(Math.sqrt(data.length))));
    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = max - min || 1;
    const binSize = range / binsCount;
    const bins = new Array(binsCount).fill(0);
    data.forEach(v => {
      let idx = Math.floor((v - min) / binSize);
      if (idx === binsCount) idx = binsCount - 1;
      bins[idx]++;
    });
    const maxBin = Math.max(...bins);
    ctxH.fillStyle = "#050c1a";
    ctxH.fillRect(0,0,w,h);
    const barW = w / binsCount;
    bins.forEach((count,i) => {
      const barH = (count / maxBin) * (h - 20);
      ctxH.fillStyle = "#1e90ff";
      ctxH.fillRect(i*barW + 4, h - barH - 10, barW - 8, barH);
    });

    // Xbar-like scatter
    const ctxX = xbarCanvas.getContext("2d");
    const w2 = xbarCanvas.width;
    const h2 = xbarCanvas.height;
    ctxX.fillStyle = "#050c1a";
    ctxX.fillRect(0,0,w2,h2);
    ctxX.strokeStyle = "#273453";
    ctxX.beginPath();
    ctxX.moveTo(20,h2/2);
    ctxX.lineTo(w2-10,h2/2);
    ctxX.stroke();

    const meanVal = mean(data);
    const min2 = Math.min(...data);
    const max2 = Math.max(...data);
    const range2 = max2 - min2 || 1;

    ctxX.fillStyle = "#4ade80";
    data.forEach((v,i) => {
      const x = 20 + (i/(data.length-1 || 1))*(w2-40);
      const y = h2 - ((v - min2)/range2)*(h2-20) - 10;
      ctxX.beginPath();
      ctxX.arc(x,y,3,0,Math.PI*2);
      ctxX.fill();
    });

    // capability curve (normalizada)
    const ctxC = capCanvas.getContext("2d");
    const w3 = capCanvas.width;
    const h3 = capCanvas.height;
    ctxC.fillStyle = "#050c1a";
    ctxC.fillRect(0,0,w3,h3);

    ctxC.strokeStyle = "#4ade80";
    ctxC.beginPath();
    ctxC.moveTo(20,h3-20);
    for (let i=0; i<100; i++) {
      const x = 20 + (i/99)*(w3-40);
      const z = -3 + 6*(i/99);
      const yNorm = Math.exp(-0.5*Math.pow(z,2));
      const y = h3-20 - yNorm*(h3-30);
      ctxC.lineTo(x,y);
    }
    ctxC.stroke();
  }

  function updateComplianceSummary() {
    complianceBody.innerHTML = "";
    const contractPcd = parseFloat(contractPcdInput.value) || null;
    const hoursPerDay = Math.min(Math.max(parseFloat(hoursPerDayInput.value) || 8,1),24);
    const eff = parseFloat(efficiencyInput.value) || 100;
    if (!laps.length) {
      return;
    }

    const groups = {};
    laps.forEach(l => {
      if (!l.total || l.total <= 0) return;
      const key = l.process + "||" + l.mode;
      if (!groups[key]) groups[key] = [];
      groups[key].push(l.total);
    });

    const contractPerHour = contractPcd && hoursPerDay ? contractPcd / hoursPerDay : null;
    const effFactor = eff / 100;

    Object.keys(groups).forEach(key => {
      const [proc, mode] = key.split("||");
      const arr = groups[key];
      const medCT = median(arr);
      const capPerHour = medCT ? 3600 / medCT : null;
      const capEff = capPerHour != null ? capPerHour * effFactor : null;
      let vs = null;
      if (contractPerHour && capEff != null) {
        vs = (capEff / contractPerHour) * 100;
      }

      const tr = document.createElement("tr");

      const tdProc = document.createElement("td");
      tdProc.textContent = proc;
      tr.appendChild(tdProc);

      const tdMode = document.createElement("td");
      tdMode.textContent = mode;
      tr.appendChild(tdMode);

      const tdMed = document.createElement("td");
      tdMed.textContent = medCT ? medCT.toFixed(2) : "-";
      tr.appendChild(tdMed);

      const tdCap = document.createElement("td");
      tdCap.textContent = capEff ? capEff.toFixed(1) : "-";
      tr.appendChild(tdCap);

      const tdVs = document.createElement("td");
      const tdVerdict = document.createElement("td");

      if (vs != null) {
        const pctStr = vs.toFixed(0) + "%";
        tdVs.textContent = pctStr;
        if (vs > 105) {
          tdVs.classList.add("tag-good");
          tdVerdict.textContent = "Capable vs contract";
        } else if (vs >= 85 && vs <= 105) {
          tdVs.classList.add("tag-warn");
          tdVerdict.textContent = "At risk – close to contract";
        } else {
          tdVs.classList.add("tag-bad");
          tdVerdict.textContent = "Not capable vs contract";
        }
      } else {
        tdVs.textContent = "-";
        tdVerdict.textContent = "";
      }

      tr.appendChild(tdVs);
      tr.appendChild(tdVerdict);
      complianceBody.appendChild(tr);
    });
  }

  // --- Copy helpers ---
  async function copyToClipboard(text) {
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        alert("Data copied to clipboard.");
      } else {
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        alert("Data ready. If it did not copy automatically, select & copy manually.");
      }
    } catch (e) {
      alert("Clipboard not available. Please select and copy manually.");
    }
  }

  function tableToTSV(table) {
    const rows = Array.from(table.querySelectorAll("tr"));
    return rows.map(row => {
      const cells = Array.from(row.querySelectorAll("th,td")).map(c => c.innerText.replace(/\t/g," "));
      return cells.join("\t");
    }).join("\n");
  }

  copyAllBtn.addEventListener("click", () => {
    const dataTable = document.getElementById("lapsTable");
    const txt = tableToTSV(dataTable);
    copyToClipboard(txt);
  });

  copySummaryBtn.addEventListener("click", () => {
    const sumTable = document.getElementById("summaryTable");
    const txt = tableToTSV(sumTable);
    copyToClipboard(txt);
  });

  // manual lap
  addManualBtn.addEventListener("click", () => {
    const proc = (processInput.value || "").trim() || "Process";
    const mode = modeSelect.value === "ml" ? "M+L/D" : "CT";
    const t1 = 0;
    const t2 = mode === "M+L/D" ? 0 : null;
    const total = 0;
    addLapRow(proc, mode, t1, t2, total);
  });

  resetBtn.addEventListener("click", () => {
    if (!confirm("Clear all laps and stats?")) return;
    laps = [];
    lapCounter = 0;
    renderLapsTable();
    recomputeAll();
    resetTimerState();
  });

  modeSelect.addEventListener("change", () => {
    setIndicators();
  });

  // initial
  resetTimerState();
  recomputeAll();
</script>
</body>
</html>
