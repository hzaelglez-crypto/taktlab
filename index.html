<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>
<style>
  :root{
    --bg-main:#07152b;
    --bg-card:#0b1f3a;
    --bg-card-soft:#0f2544;
    --accent-green:#00c853;
    --accent-amber:#ffb300;
    --accent-red:#ff1744;
    --accent-blue:#29b6f6;
    --accent-grey:#cfd8dc;
    --text-main:#ffffff;
    --text-soft:#c5cae9;
    --text-muted:#90a4ae;
    --border-soft:#1c3357;
    --btn-green:#00c853;
    --btn-orange:#ff9100;
    --btn-grey:#455a64;
    --badge-green:#004d40;
    --badge-red:#b71c1c;
    --badge-amber:#ff8f00;
  }

  *{box-sizing:border-box;}

  body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 40%,#020b1a 100%);
    color:var(--text-main);
  }

  .page{
    max-width:1100px;
    margin:0 auto;
    padding:12px 10px 40px;
  }

  /* ===== Sticky ONLY timer bar (title + display + Start/Lap) ===== */
  .sticky-timer-bar{
    position:sticky;
    top:0;
    z-index:100;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 90%);
    padding:8px 0 10px;
  }

  .top-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
  }

  .logo-circle{
    width:38px;
    height:38px;
    border-radius:50%;
    border:2px solid var(--accent-grey);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
  }
  .logo-gear{
    width:22px;
    height:22px;
    border-radius:50%;
    border:2px solid var(--accent-grey);
    position:relative;
  }
  .logo-gear::before{
    content:"";
    position:absolute;
    inset:4px;
    border-radius:50%;
    border:2px solid var(--accent-green);
    border-right-color:transparent;
    border-bottom-color:transparent;
    transform-origin:50% 50%;
  }
  .logo-gear.spinning::before{
    animation:logo-spin 2s linear infinite;
  }
  @keyframes logo-spin{
    from{transform:rotate(0deg);}
    to{transform:rotate(360deg);}
  }

  .title-block{
    display:flex;
    flex-direction:column;
    gap:2px;
  }
  .title-main{
    font-size:1.2rem;
    font-weight:700;
    letter-spacing:.03em;
  }
  .title-sub{
    font-size:.72rem;
    color:var(--text-soft);
  }

  /* == Language switch == */
  .lang-switch{
    margin-left:auto;
    display:flex;
    align-items:center;
    gap:4px;
  }
  .lang-btn{
    border-radius:999px;
    border:1px solid var(--border-soft);
    background:rgba(2,11,26,.6);
    color:var(--text-soft);
    font-size:.7rem;
    padding:4px 8px;
    cursor:pointer;
    min-width:34px;
  }
  .lang-btn.active{
    background:var(--accent-blue);
    color:#fff;
    border-color:var(--accent-blue);
    font-weight:600;
  }

  .timer-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:6px 10px 10px;
    box-shadow:0 8px 18px rgba(0,0,0,.45);
  }

  .timer-display{
    text-align:center;
    font-size:2.8rem;
    font-weight:600;
    letter-spacing:.08em;
    padding:4px 4px 10px;
  }

  /* Bloque de info de muestra bajo el cronómetro */
  .sample-info{
    font-size:.78rem;
    margin:0 0 6px;
    padding:4px 8px;
    border-radius:10px;
    border:1px solid transparent;
  }
  .sample-neutral{
    background:rgba(255,255,255,.03);
    border-color:rgba(255,255,255,.08);
    color:var(--text-soft);
  }
  .sample-good{
    background:rgba(0,200,83,.15);
    border-color:rgba(0,200,83,.7);
    color:#c8e6c9;
  }
  .sample-warn{
    background:rgba(255,193,7,.14);
    border-color:rgba(255,193,7,.8);
    color:#ffe082;
  }
  .sample-bad{
    background:rgba(244,67,54,.16);
    border-color:rgba(244,67,54,.9);
    color:#ffab91;
  }

  .btn-row-main{
    display:flex;
    gap:10px;
    margin-bottom:2px;
  }
  .btn{
    border:none;
    border-radius:16px;
    padding:10px 12px;
    font-size:.9rem;
    font-weight:600;
    cursor:pointer;
    color:#fff;
    box-shadow:0 4px 10px rgba(0,0,0,.4);
    flex:1;
    transition:transform .04s ease, box-shadow .04s ease, background .15s;
    touch-action:manipulation;
  }
  .btn:active{
    transform:translateY(1px);
    box-shadow:0 1px 4px rgba(0,0,0,.5);
  }
  .btn-start{background:var(--btn-green);}
  .btn-lap{background:var(--btn-orange);}

  .flash{
    animation:flash-bg .12s ease-out;
  }
  @keyframes flash-bg{
    from{background:rgba(255,255,255,.18);}
    to{background:transparent;}
  }

  /* Rest of page */
  .content-section{margin-top:10px;}

  .section-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:10px 10px 12px;
    margin-bottom:10px;
  }
  .section-title{
    font-size:.9rem;
    font-weight:600;
    margin-bottom:6px;
  }

  .mode-row{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
    font-size:.78rem;
    color:var(--text-soft);
  }
  .mode-row.label{font-weight:500;}
  .mode-row select,
  .mode-row input{
    background:#020b1a;
    border-radius:8px;
    border:1px solid var(--border-soft);
    padding:4px 8px;
    color:var(--text-soft);
    font-size:.78rem;
    min-width:70px;
  }
  .mode-row input[type="number"]{width:70px;}

  /* T1/T2 mini indicators */
  .mini-t12-wrapper{
    display:flex;
    gap:8px;
    margin-top:8px;
  }
  .mini-t12{
    flex:1;
    background:#020b1a;
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:6px 10px;
    display:flex;
    align-items:center;
    gap:8px;
    min-height:56px;
  }
  .mini-ring{
    width:36px;
    height:36px;
    border-radius:50%;
    border:3px solid rgba(255,255,255,.08);
    position:relative;
    overflow:hidden;
    /* oculto por ahora */
    display:none;
  }
  .mini-ring::before{
    content:"";
    position:absolute;
    inset:-3px;
    border-radius:50%;
    border:3px solid transparent;
    border-top-color:var(--accent-green);
    border-right-color:var(--accent-green);
    transform-origin:50% 50%;
    animation:ring-spin 1.2s linear infinite;
    opacity:.2;
  }
  .mini-ring.paused::before{
    animation-play-state:paused;
    opacity:.35;
  }
  @keyframes ring-spin{
    from{transform:rotate(0);}
    to{transform:rotate(360deg);}
  }
  .mini-label{font-size:.72rem;color:var(--text-soft);}
  .mini-value{font-size:.95rem;font-weight:600;}

  table{
    width:100%;
    border-collapse:collapse;
    font-size:.75rem;
  }
  th,td{
    padding:4px 6px;
    text-align:right;
    border-bottom:1px solid rgba(255,255,255,.04);
  }
  th:first-child,td:first-child{text-align:left;}
  th{
    color:var(--text-soft);
    font-weight:600;
    background:rgba(255,255,255,.02);
    position:sticky;
    top:0;
    z-index:5;
  }
  tbody tr:nth-child(even){
    background:rgba(255,255,255,.02);
  }

  .badge{
    display:inline-block;
    padding:2px 6px;
    border-radius:999px;
    font-size:.68rem;
    border:1px solid transparent;
  }
  .badge-good{background:var(--badge-green);border-color:#00e676;}
  .badge-warn{background:var(--badge-amber);border-color:#ffe082;}
  .badge-bad{background:var(--badge-red);border-color:#ff8a80;}

  /* Botones Data Controls (más grandes y de colores) */
  .btn-row-secondary{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin:8px 0 4px;
  }
  .btn-small{
    padding:8px 14px;
    border-radius:14px;
    font-size:.8rem;
    font-weight:600;
    flex:0 0 auto;
    background:var(--bg-card-soft);
    color:var(--text-soft);
    border:1px solid var(--border-soft);
    cursor:pointer;
    box-shadow:0 3px 8px rgba(0,0,0,.35);
    transition:transform .04s ease, box-shadow .04s ease, background .15s, color .15s, border-color .15s;
  }
  .btn-small:active{
    transform:translateY(1px);
    box-shadow:0 1px 4px rgba(0,0,0,.45);
  }
  .btn-small-copy{
    background:var(--accent-blue);
    border-color:var(--accent-blue);
    color:#fff;
  }
  .btn-small-summary{
    background:var(--accent-amber);
    border-color:var(--accent-amber);
    color:#000;
  }
  .btn-small-manual{
    background:var(--accent-green);
    border-color:var(--accent-green);
    color:#000;
  }
  .btn-small-reset{
    background:var(--accent-red);
    border-color:var(--accent-red);
    color:#fff;
  }

  .btn-edit,.btn-del{
    padding:2px 6px;
    border-radius:8px;
    font-size:.7rem;
    border:1px solid rgba(255,255,255,.2);
    cursor:pointer;
    background:transparent;
  }
  .btn-edit{color:#81d4fa;}
  .btn-del{color:#ff8a80;}

  .stats-focus{
    font-size:.74rem;
    line-height:1.3;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .focus-line{
    padding:3px 6px;
    border-radius:8px;
  }
  .focus-good{background:rgba(0,200,83,.12);border:1px solid rgba(0,200,83,.6);}
  .focus-warn{background:rgba(255,193,7,.08);border:1px solid rgba(255,193,7,.6);}
  .focus-bad{background:rgba(244,67,54,.12);border:1px solid rgba(244,67,54,.7);}

  .footer-note{
    margin-top:10px;
    font-size:.65rem;
    color:var(--text-muted);
    text-align:right;
  }

  /* Charts */
  .charts-wrapper{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:10px;
  }
  .chart-card{
    background:var(--bg-card-soft);
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:8px;
  }
  .chart-title{
    font-size:.75rem;
    margin-bottom:4px;
    color:var(--text-soft);
  }
  canvas{
    width:100%;
    height:180px;
    background:#020b1a;
    border-radius:10px;
  }

  /* Capacity Snapshot */
  .capacity-snapshot{
    margin-top:6px;
    font-size:.76rem;
    line-height:1.3;
    border-top:1px solid rgba(255,255,255,.06);
    padding-top:6px;
  }
  .snapshot-line{
    margin-bottom:2px;
  }
  .capacity-gain{
    color:var(--accent-green);
    font-weight:700;
    margin-left:4px;
  }

  /* Method & Guide */
  .method-details{
    font-size:.75rem;
    margin-bottom:6px;
    background:var(--bg-card-soft);
    border-radius:10px;
    border:1px solid var(--border-soft);
    padding:4px 6px;
  }
  .method-details summary{
    cursor:pointer;
    font-weight:600;
    list-style:none;
  }
  .method-details summary::-webkit-details-marker{
    display:none;
  }
  .method-details summary::before{
    content:"+";
    margin-right:6px;
    color:var(--accent-blue);
    font-weight:700;
  }
  .method-details[open] summary::before{
    content:"–";
  }
  .method-body{
    margin-top:4px;
    color:var(--text-soft);
  }
  .method-body ul{
    padding-left:16px;
    margin:4px 0;
  }
  .method-body li{
    margin-bottom:2px;
  }

  @media (max-width:600px){
    .timer-display{font-size:2.2rem;}
    .btn-row-main{gap:6px;}
    .btn{font-size:.9rem;border-radius:14px;}
    canvas{height:160px;}
  }
</style>
</head>
<body>
<div class="page">

  <!-- STICKY BAR: SOLO cronómetro + Start/Lap -->
  <div class="sticky-timer-bar">
    <div class="top-row">
      <div class="logo-circle">
        <div class="logo-gear" id="logoGear"></div>
      </div>
      <div class="title-block">
        <div class="title-main">TaktLab</div>
        <div class="title-sub" data-i18n="title.subtitle">
          Cycle Time &amp; Capacity Analyzer
        </div>
      </div>
      <div class="lang-switch">
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="es">ES</button>
      </div>
    </div>

    <div class="timer-card" id="timerCard">
      <div class="timer-display" id="display">00:00.00</div>

      <!-- Info de muestras estandarizada -->
      <div class="sample-info sample-neutral" id="sampleInfo">
        No samples yet for current process. Start capturing laps.
      </div>

      <div class="btn-row-main">
        <button class="btn btn-start" id="btnStart" data-i18n="btn.start">Start</button>
        <button class="btn btn-lap" id="btnLap" data-i18n="btn.lap">LAP</button>
      </div>
    </div>
  </div>

  <!-- CONTENIDO NORMAL -->
  <div class="content-section">

    <!-- DATA CONTROLS (subido arriba de Measurement Setup) -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.dataControls">Data Controls</div>
      <div class="btn-row-secondary">
        <button class="btn-small btn-small-copy" id="btnCopyAll" data-i18n="btn.copyAll">Copy All</button>
        <button class="btn-small btn-small-summary" id="btnCopySummary" data-i18n="btn.copySummary">Copy Summary</button>
        <button class="btn-small btn-small-manual" id="btnAddManualLap" data-i18n="btn.addManualLap">Add Manual Lap</button>
        <button class="btn-small btn-small-reset" id="btnReset" data-i18n="btn.reset">
          Reset
        </button>
      </div>
    </div>

    <!-- CONFIGURACIÓN DE MEDICIÓN -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.measurementSetup">
        Measurement Setup
      </div>

      <div class="mode-row">
        <div>
          <label for="processName" data-i18n="label.process">Process</label><br/>
          <input id="processName" type="text"
            placeholder="e.g. Op 30-1"
            data-i18n-placeholder="label.processPlaceholder"/>
        </div>

        <div>
          <label for="mode" data-i18n="label.mode">Mode</label><br/>
          <select id="mode">
            <option value="CT" data-i18n="mode.ct">Cycle Time (CT)</option>
            <option value="MLD" data-i18n="mode.mld">Machine &amp; Load/Unload</option>
          </select>
        </div>

        <div>
          <label for="efficiency" data-i18n="label.efficiency">Efficiency %</label><br/>
          <input id="efficiency" type="number" value="100" min="10" max="100" step="1"/>
        </div>

        <div>
          <label for="contractPcd" data-i18n="label.contractPcd">
            Contract Cap (pcs/day)
          </label><br/>
          <input id="contractPcd" type="number" min="0" step="1"/>
        </div>

        <div>
          <label for="hoursPerDay" data-i18n="label.hoursPerDay">
            Hours / Day
          </label><br/>
          <input id="hoursPerDay" type="number" value="8" min="1" max="24" step=".5"/>
        </div>

        <div>
          <label for="daysPerWeek" data-i18n="label.daysPerWeek">
            Days / Week
          </label><br/>
          <input id="daysPerWeek" type="number" value="5" min="1" max="7"/>
        </div>

        <div>
          <label for="capView" data-i18n="label.capView">
            Capacity View
          </label><br/>
          <select id="capView">
            <option value="hour" data-i18n="capView.hour">per Hour</option>
            <option value="day" data-i18n="capView.day">per Day</option>
            <option value="week" data-i18n="capView.week">per Week</option>
          </select>
        </div>
      </div>

      <!-- MINI INDICADORES -->
      <div class="mini-t12-wrapper">
        <div class="mini-t12">
          <div class="mini-ring paused" id="ringT1"></div>
          <div>
            <div class="mini-label" data-i18n="mini.t1Label">T1 – Machine</div>
            <div class="mini-value" id="t1Indicator">0.0 s</div>
          </div>
        </div>

        <div class="mini-t12">
          <div class="mini-ring paused" id="ringT2"></div>
          <div>
            <div class="mini-label" data-i18n="mini.t2Label">T2 – Load/Unload</div>
            <div class="mini-value" id="t2Indicator">0.0 s</div>
          </div>
        </div>
      </div>

    </div>
    <!-- ⭐ STATS FOCUS (DEBAJO DE CONFIGURACIÓN) -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.statsFocus">
        Stats Focus
      </div>

      <div class="stats-focus" id="statsFocus"></div>

      <div
        style="margin-top:6px;font-size:.68rem;color:var(--text-muted);"
        data-i18n="stats.note">
        Simple language on purpose: few / enough samples,
        low / high variation, close to normal / not normal, capable / not capable.
      </div>
    </div>

    <!-- ⭐ CONTRACT VS CAPACITY SUMMARY (DEBAJO DE STATS FOCUS) -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.contractSummary">
        Contract vs Capacity Summary
      </div>
      <div id="contractSummary" style="font-size:.78rem;"></div>

      <!-- SNAPSHOT -->
      <div id="capacitySnapshot" class="capacity-snapshot"></div>
    </div>

    <!-- PROCESS CAPACITY OVERVIEW -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.capacityOverview">
        Process Capacity Overview
      </div>

      <table id="overviewTable">
        <thead>
          <tr>
            <th data-i18n="col.process">Process</th>
            <th data-i18n="col.mode">Mode</th>
            <th data-i18n="col.n">N</th>
            <th>CTmed (s)</th>
            <th>Cap 100%</th>
            <th>Cap @Eff</th>
            <th>% vs contract</th>
          </tr>
        </thead>
        <tbody id="overviewBody"></tbody>
      </table>
    </div>

    <!-- ESTADÍSTICA DETALLADA -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.statsDetail">
        Statistical Detail (per process)
      </div>

      <div style="max-height:260px;overflow:auto;">
        <table id="statsTable">
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.n">N</th>
              <th>Mean</th>
              <th>Median</th>
              <th>P10</th>
              <th>P90</th>
              <th>Min</th>
              <th>Max</th>
              <th>Std</th>
              <th>CV%</th>
              <th>Cp</th>
              <th>Cpk</th>
            </tr>
          </thead>
          <tbody id="statsBody"></tbody>
        </table>
      </div>
    </div>

    <!-- GRÁFICAS -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.charts">
        Charts (selected process)
      </div>

      <div style="margin-bottom:6px;font-size:.75rem;">
        <label for="chartProcessSelect" data-i18n="label.chartProcessLabel">
          Process / Mode:
        </label>
        <select id="chartProcessSelect"></select>
      </div>

      <div class="charts-wrapper">
        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.timeSeriesTitle">
            Time Series with Mean, Median, ±3σ
          </div>
          <canvas id="timeSeriesCanvas"></canvas>
        </div>

        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.histTitle">
            Histogram with Median &amp; Percentiles
          </div>
          <canvas id="histCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Raw Time Data -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.rawData">Raw Time Data</div>
      <div style="max-height:320px;overflow:auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th data-i18n="col.index">#</th>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.status">Status</th>
              <th data-i17n="col.note">Note</th>
              <th data-i18n="col.t1">T1 (s)</th>
              <th data-i18n="col.t2">T2 (s)</th>
              <th data-i18n="col.total">Total (s)</th>
              <th data-i18n="col.edit">Edit</th>
              <th data-i18n="col.del">Del</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Method & Guide (desplegable) -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.methodGuide">Method &amp; Guide</div>

      <details class="method-details">
        <summary data-i18n="method.howTitle">How TaktLab estimates capacity</summary>
        <div class="method-body">
          <ul>
            <li><strong>Cycle times:</strong> based on <strong>raw laps</strong> taken at the process (CT or Machine + Load/Unload).</li>
            <li><strong>CTmed (s):</strong> capacity is calculated using the <strong>median</strong> of the total time (T1+T2 when applicable).</li>
            <li><strong>Capacity 100%:</strong> 3600 / CTmed → units/hour, then scaled to day/week with the hours &amp; days you set.</li>
            <li><strong>Capacity @Eff:</strong> applies the Efficiency % (OEE or planned effectiveness) to the theoretical 100% capacity.</li>
            <li><strong>Contract vs capacity:</strong> compares Capacity @Eff vs Contract Cap, using the selected capacity view (hour/day/week).</li>
            <li><strong>Potential capacity:</strong> uses the <strong>P10 (best 10%)</strong> of the distribution as the target if the process is stabilized.</li>
          </ul>
        </div>
      </details>

      <details class="method-details">
        <summary data-i18n="method.whatTitle">What to enter in each field</summary>
        <div class="method-body">
          <ul>
            <li><strong>Process:</strong> operation ID or description (e.g. “Op 30-1 Mazak #3”).</li>
            <li><strong>Mode:</strong> CT when you only care about total cycle; Machine &amp; Load/Unload when you want T1 vs T2 split.</li>
            <li><strong>Efficiency %:</strong> expected OEE / planned effectiveness (e.g. 85%).</li>
            <li><strong>Contract Cap (pcs/day):</strong> daily volume committed to customer for that process/part number.</li>
            <li><strong>Hours / Day &amp; Days / Week:</strong> planned schedule actually available for that process (net calendar).</li>
            <li><strong>Capacity View:</strong> choose whether you want capacity per hour, per day or per week in the tables and snapshot.</li>
          </ul>
        </div>
      </details>

      <!-- NUEVO BLOQUE: guía rápida de tamaño de muestra -->
      <details class="method-details">
        <summary data-i18n="method.sampleTitle">Sample size &amp; error – quick guide</summary>
        <div class="method-body">
          <p>
            TaktLab links <strong>sample size</strong> (N), <strong>variation</strong> (CV) and the
            <strong>estimated error</strong> of the mean at 95% confidence.
          </p>
          <ul>
            <li><strong>More variation</strong> (higher CV) ⇒ you need <strong>more samples</strong>.</li>
            <li><strong>Target in TaktLab:</strong> be close to ±3% error at 95% confidence on critical/bottleneck processes.</li>
            <li>
              As a rule of thumb:
              <ul>
                <li>Low CV (&lt;8%) → ~10 laps are usually enough.</li>
                <li>Medium CV (8–20%) → ~15–25 laps.</li>
                <li>High CV (&gt;20%) → ~25–40+ laps.</li>
              </ul>
            </li>
            <li>
              The banner under the stopwatch and the <strong>Stats Focus</strong> block show:
              <strong>Sample size N / N<sub>target</sub></strong> and the estimated error (±% @95%).
            </li>
          </ul>
          <p>
            Use this as a <strong>guide</strong>, not a rigid rule. If the process is very unstable or mix changes a lot,
            take more samples and split the studies by family or condition.
          </p>
        </div>
      </details>

      <!-- BLOQUE Cp/Cpk -->
      <details class="method-details">
        <summary data-i18n="method.cpTitle">Cp &amp; Cpk – quick interpretation</summary>
        <div class="method-body">
          <p>
            TaktLab uses your <strong>contract capacity</strong> (pcs/day) and planned hours/day to build a <strong>cycle-time target</strong>.
            That target is treated as an <strong>upper spec limit (USL)</strong> for capability:
          </p>
          <ul>
            <li><strong>Cp</strong> = (USL − LSL) / (6·σ). Here LSL is 0 s and USL is the CT target. Cp tells you the <strong>potential</strong> capability if the process were perfectly centered.</li>
            <li><strong>Cpk</strong> = min(Cpu, Cpl) = min[(USL − μ)/(3·σ), (μ − LSL)/(3·σ)]. It reflects the <strong>real</strong> capability with your current mean and spread.</li>
          </ul>
          <p>Fast rules of thumb for decision-making:</p>
          <ul>
            <li><strong>Cpk &lt; 1.00</strong> → <strong>Not capable</strong> vs target. Expect chronic backlog or need for overtime. This is where you should attack first.</li>
            <li><strong>1.00 ≤ Cpk &lt; 1.33</strong> → <strong>Borderline</strong>. You can run, but you have little protection against mix changes, breakdowns or demand spikes.</li>
            <li><strong>Cpk ≥ 1.33</strong> → <strong>Capable</strong> vs target. Improvements here are “nice to have” unless this is the bottleneck.</li>
          </ul>
          <p>
            Remember: these Cp/Cpk values are valid <strong>only if</strong> the data represent a reasonably stable process and the time-study method is consistent
            (same product family, same operator group, same conditions).
          </p>
        </div>
      </details>

      <details class="method-details">
        <summary data-i18n="method.noticeTitle">Important notice / disclaimer</summary>
        <div class="method-body">
          <p>
            TaktLab is a <strong>decision-support tool</strong> based on time studies and basic statistical analysis (median, percentiles,
            standard deviation). Results depend on:
          </p>
          <ul>
            <li>The quality of the time measurements (method, operator, conditions).</li>
            <li>The number of samples taken and the stability of the process during the study.</li>
            <li>The assumptions entered by the user (Efficiency %, hours/day, days/week, contract volume).</li>
          </ul>
          <p>
            The “capacity” and “potential” values are <strong>estimates</strong>, not guarantees. Any change in staffing, methods,
            maintenance, product mix or demand can modify the real output. Use the results as a structured reference to support
            engineering and management discussions, always combined with your local standards and technical judgement.
          </p>
          <p>
            For support, feedback or custom studies: <strong>hzaelglez@gmail.com</strong>.
          </p>
        </div>
      </details>
    </div>

  </div>

  <div class="footer-note" data-i18n="footer.note">
    Created by Roberto González – Contact: hzaelglez@gmail.com
  </div>
</div>
<script>
(function(){

/* ============================================================
   GLOBAL STATE
============================================================ */
let running = false;
let startTime = 0;
let lastLapTime = 0;
let timerInterval = null;

/* Estructura de datos por proceso:
   {
     "Op 30-1|CT": {
         mode:"CT",
         samples:[ {t1,t2,total, status, note} ],
         stats:{...}
     }
   }
*/
let processData = {};

/* Element refs */
const display      = document.getElementById("display");
const btnStart     = document.getElementById("btnStart");
const btnLap       = document.getElementById("btnLap");
const sampleInfo   = document.getElementById("sampleInfo");
const processName  = document.getElementById("processName");
const modeSel      = document.getElementById("mode");
const efficiencyEl = document.getElementById("efficiency");
const contractPcd  = document.getElementById("contractPcd");
const hoursPerDayEl= document.getElementById("hoursPerDay");
const daysPerWeekEl= document.getElementById("daysPerWeek");
const capViewSel   = document.getElementById("capView");

const t1Indicator  = document.getElementById("t1Indicator");
const t2Indicator  = document.getElementById("t2Indicator");
const ringT1       = document.getElementById("ringT1");
const ringT2       = document.getElementById("ringT2");

const statsFocusDiv= document.getElementById("statsFocus");
const contractSummaryDiv = document.getElementById("contractSummary");
const capacitySnapshotDiv = document.getElementById("capacitySnapshot");

const overviewBody = document.getElementById("overviewBody");
const statsBody    = document.getElementById("statsBody");
const dataBody     = document.getElementById("dataBody");

const btnCopyAll      = document.getElementById("btnCopyAll");
const btnCopySummary  = document.getElementById("btnCopySummary");
const btnAddManualLap = document.getElementById("btnAddManualLap");
const btnReset        = document.getElementById("btnReset");

const chartSelect = document.getElementById("chartProcessSelect");

const timeSeriesCanvas = document.getElementById("timeSeriesCanvas");
const histCanvas       = document.getElementById("histCanvas");

let timeSeriesChart = null;
let histChart       = null;

/* Logo Gear animado */
const logoGear = document.getElementById("logoGear");

/* ============================================================
   VIBRATION + FLASH EFFECTS
============================================================ */
function smallVibration(){
  if (navigator.vibrate){
    try{ navigator.vibrate(35); }catch(e){}
  }
}

function flashCard(){
  const card = document.getElementById("timerCard");
  if (!card) return;
  card.classList.add("flash");
  setTimeout(()=>card.classList.remove("flash"),120);
}

/* ============================================================
   TIMER
============================================================ */
function formatTime(ms){
  const totalSeconds = ms/1000;
  const minutes = Math.floor(totalSeconds/60);
  const seconds = (totalSeconds % 60).toFixed(2).padStart(5,"0");
  return `${String(minutes).padStart(2,"0")}:${seconds}`;
}

function updateDisplay(){
  const now = performance.now();
  const elapsed = now - startTime;
  display.textContent = formatTime(elapsed);
}

function startTimer(){
  running = true;
  startTime = performance.now();
  lastLapTime = startTime;

  logoGear.classList.add("spinning");

  timerInterval = setInterval(updateDisplay,10);

  btnStart.textContent = currentLang==="es" ? "Stop" : "Stop";
}

function stopTimer(){
  running = false;
  logoGear.classList.remove("spinning");

  clearInterval(timerInterval);
  timerInterval = null;

  btnStart.textContent = currentLang==="es" ? "Start" : "Start";
  updateDisplay();
}

/* ============================================================
   ADD LAP (MANUAL O AUTOMÁTICO)
============================================================ */
function addLap(manual=false){
  const now = performance.now();
  const lapMs = now - lastLapTime;
  lastLapTime = now;

  const proc = processName.value.trim() || "(no name)";
  const mode = modeSel.value;
  const key = `${proc}|${mode}`;

  if (!processData[key]) processData[key] = {
    mode,
    samples:[],
    stats:{}
  };

  // Si es MLD separamos T1 y T2
  let t1 = 0, t2 = 0;
  if (mode==="MLD"){
    t1 = parseFloat(prompt(currentLang==="es"
      ? "Ingresa T1 (Machine) en segundos:"
      : "Enter T1 (Machine) in seconds:","0")) || 0;
    t2 = parseFloat(prompt(currentLang==="es"
      ? "Ingresa T2 (Load/Unload) en segundos:"
      : "Enter T2 (Load/Unload) in seconds:","0")) || 0;
  }

  const total = mode==="MLD" ? t1+t2 : lapMs/1000;

  processData[key].samples.push({
    t1, t2, total,
    status: manual ? "manual" : "auto",
    note:""
  });

  smallVibration();
  flashCard();

  refreshTables();
  refreshStatsFocus();
  refreshContractSummary();
  refreshCharts();
  updateSampleBanner(key);
}

/* ============================================================
   SAMPLE BANNER – UNIFICADO
============================================================ */
function updateSampleBanner(key){
  const d = processData[key];
  if (!d || d.samples.length===0){
    sampleInfo.className="sample-info sample-neutral";
    sampleInfo.textContent = currentLang==="es"
      ? "Aún no hay muestras en este proceso. Inicia capturas."
      : "No samples yet for current process. Start capturing laps.";
    return;
  }

  // Calcular error estimado ±Z·σ/√N (95% → 1.96)
  const Z = 1.96;
  const times = d.samples.map(s=>s.total);
  const N = times.length;
  const mean = times.reduce((a,b)=>a+b,0)/N;
  const variance = times.reduce((a,b)=>a+(b-mean)**2,0)/N;
  const std = Math.sqrt(variance);
  const estError = (Z * std / Math.sqrt(N)) / mean * 100;  // %

  const targetError = 3; // objetivo ±3%
  let cls = "sample-neutral";
  if (estError<=targetError) cls="sample-good";
  else if (estError <= targetError*2) cls="sample-warn";
  else cls="sample-bad";

  sampleInfo.className = `sample-info ${cls}`;

  const msg = currentLang==="es"
    ? `Muestras: ${N} · Error estimado: ±${estError.toFixed(1)}% (95%)`
      + (estError<=3
         ? " – adecuado para decisiones."
         : " – muestra insuficiente para ±3%, usar solo como referencia.")
    : `Samples: ${N} · Est. error: ±${estError.toFixed(1)}% (95%)`
      + (estError<=3
         ? " – enough for decisions."
         : " – too small for ±3%, use only as reference.");

  sampleInfo.textContent = msg;
}
/* ============================================================
   RECONSTRUCCIÓN DE ESTADÍSTICAS PARA CADA PROCESO
============================================================ */
function computeStatsForProcess(key){
  const d = processData[key];
  if (!d || d.samples.length===0){
    d.stats = {};
    return;
  }

  const samples = d.samples.map(s=>s.total);
  const N = samples.length;

  // Media
  const mean = samples.reduce((a,b)=>a+b,0)/N;

  // Mediana
  const sorted = [...samples].sort((a,b)=>a-b);
  let median = 0;
  if (N%2===0) median = (sorted[N/2 -1] + sorted[N/2]) / 2;
  else median = sorted[(N-1)/2];

  // Percentiles
  const p10 = sorted[Math.floor(0.10*(N-1))];
  const p90 = sorted[Math.floor(0.90*(N-1))];

  // Min y Max
  const min = sorted[0];
  const max = sorted[sorted.length-1];

  // Std dev
  const variance = samples.reduce((a,b)=>a+(b-mean)**2,0)/N;
  const std = Math.sqrt(variance);

  // CV%
  const cv = (std/mean)*100;

  // Target CT calculado desde contrato
  const hours = parseFloat(hoursPerDayEl.value)||8;
  const contract = parseFloat(contractPcd.value)||0;
  let ctTarget = 0;
  if (contract>0){
    ctTarget = (hours*3600)/contract; // segundos
  } else {
    ctTarget = median*0.9; // fallback
  }

  // Cp / Cpk
  const USL = ctTarget;
  const LSL = 0;
  let Cp=0, Cpk=0;
  if (std>0){
    Cp = (USL - LSL)/(6*std);
    const Cpu = (USL - mean)/(3*std);
    const Cpl = (mean - LSL)/(3*std);
    Cpk = Math.min(Cpu,Cpl);
  }

  d.stats = {
    N, mean, median, p10, p90, min, max,
    std, cv, Cp, Cpk, ctTarget
  };
}

/* ============================================================
   RECONSTRUIR TODAS LAS TABLAS
============================================================ */
function refreshTables(){
  overviewBody.innerHTML="";
  statsBody.innerHTML="";
  dataBody.innerHTML="";
  chartSelect.innerHTML="";

  for (const key of Object.keys(processData)){
    computeStatsForProcess(key);
  }

  // Llenar tablas
  for (const key of Object.keys(processData)){
    const d = processData[key];
    const stats = d.stats || {};
    const [proc, mode] = key.split("|");

    /* ------------------------
       OVERVIEW TABLE
    ------------------------ */
    if (stats.N>0){
      const hours = parseFloat(hoursPerDayEl.value)||8;
      const eff   = (parseFloat(efficiencyEl.value)||100)/100;

      const ctmed = stats.median;
      const cap100ph = ctmed>0 ? 3600/ctmed : 0;
      const capEffph = cap100ph * eff;

      const contract = parseFloat(contractPcd.value)||0;
      const pctVs = contract>0 ? (capEffph*hours)/contract*100 : 0;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${stats.N}</td>
        <td>${ctmed.toFixed(2)}</td>
        <td>${cap100ph.toFixed(1)}</td>
        <td>${capEffph.toFixed(1)}</td>
        <td>${pctVs.toFixed(0)}%</td>
      `;
      overviewBody.appendChild(tr);
    }

    /* ------------------------
       STATS TABLE
    ------------------------ */
    if (stats.N>0){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${stats.N}</td>
        <td>${stats.mean.toFixed(2)}</td>
        <td>${stats.median.toFixed(2)}</td>
        <td>${stats.p10.toFixed(2)}</td>
        <td>${stats.p90.toFixed(2)}</td>
        <td>${stats.min.toFixed(2)}</td>
        <td>${stats.max.toFixed(2)}</td>
        <td>${stats.std.toFixed(2)}</td>
        <td>${stats.cv.toFixed(1)}%</td>
        <td>${stats.Cp.toFixed(2)}</td>
        <td>${stats.Cpk.toFixed(2)}</td>
      `;
      statsBody.appendChild(tr);
    }

    /* ------------------------
       RAW DATA TABLE
    ------------------------ */
    for (let i=0; i<d.samples.length; i++){
      const s = d.samples[i];
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${i+1}</td>
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${s.status}</td>
        <td>${s.note||""}</td>
        <td>${s.t1.toFixed(2)}</td>
        <td>${s.t2.toFixed(2)}</td>
        <td>${s.total.toFixed(2)}</td>
        <td><button class="btn-edit" onclick="editSample('${key}',${i})">✎</button></td>
        <td><button class="btn-del" onclick="deleteSample('${key}',${i})">✖</button></td>
      `;
      dataBody.appendChild(tr);
    }

    /* ------------------------
       CHART PROCESS SELECT
    ------------------------ */
    const opt = document.createElement("option");
    opt.value = key;
    opt.textContent = `${proc} (${mode})`;
    chartSelect.appendChild(opt);
  }

  refreshCharts();
}

/* ============================================================
   FUNCIONES PARA EDITAR / BORRAR SAMPLES
============================================================ */
window.editSample = function(key, index){
  const d = processData[key];
  if (!d) return;
  const s = d.samples[index];
  if (!s) return;

  const newNote = prompt(
    currentLang==="es" ? "Editar nota:" : "Edit note:",
    s.note || ""
  );
  if (newNote !== null){
    s.note = newNote;
  }
  refreshTables();
  refreshStatsFocus();
  refreshContractSummary();
};

window.deleteSample = function(key, index){
  const d = processData[key];
  if (!d) return;
  d.samples.splice(index,1);
  refreshTables();
  refreshStatsFocus();
  refreshContractSummary();
};

/* ============================================================
   STATS FOCUS — BLOQUE COMBINADO (TU NUEVO FORMATO)
============================================================ */
function refreshStatsFocus(){
  statsFocusDiv.innerHTML = "";

  for (const key of Object.keys(processData)){
    const d = processData[key];
    if (!d || d.samples.length===0) continue;
    const stats = d.stats;
    const [proc, mode] = key.split("|");

    const N = stats.N;
    const med = stats.median;
    const mean = stats.mean;
    const std = stats.std;
    const cv = stats.cv;
    const Cp = stats.Cp;
    const Cpk = stats.Cpk;

    const good = (txt)=>`<div class="focus-line focus-good">${txt}</div>`;
    const warn = (txt)=>`<div class="focus-line focus-warn">${txt}</div>`;
    const bad  = (txt)=>`<div class="focus-line focus-bad">${txt}</div>`;

    let blk = `<div style="margin-bottom:8px;"><strong>${proc} (${mode})</strong></div>`;

    /* -------- Tamaño de muestra -------- */
    if (N>=10) blk += good(
      currentLang==="es"
        ? `Tamaño de muestra: ${N} – suficiente para decisiones con objetivo ±3%.`
        : `Sample size: ${N} – enough for ±3% decisions.`
    );
    else blk += bad(
      currentLang==="es"
        ? `Tamaño de muestra: ${N} – insuficiente, tomar más datos.`
        : `Sample size: ${N} – too small, add more laps.`
    );

    /* -------- Std dev -------- */
    blk += (std<=0.08*mean)
      ? good(
          currentLang==="es"
            ? `Std dev ≈ ${std.toFixed(2)} s (${cv.toFixed(1)}%). Baja variación — proceso estable.`
            : `Std dev ≈ ${std.toFixed(2)} s (${cv.toFixed(1)}%). Low variation — process stable.`
        )
      : warn(
          currentLang==="es"
            ? `Std dev ≈ ${std.toFixed(2)} s (${cv.toFixed(1)}%). Variación algo alta.`
            : `Std dev ≈ ${std.toFixed(2)} s (${cv.toFixed(1)}%). Variation somewhat high.`
        );

    /* -------- Media/Mediana -------- */
    blk += good(
      currentLang==="es"
        ? `Media ≈ ${mean.toFixed(1)} s, Mediana ≈ ${med.toFixed(1)} s. Distribución cercana a normal.`
        : `Mean ≈ ${mean.toFixed(1)} s, Median ≈ ${med.toFixed(1)} s. Distribution close to normal.`
    );

    /* -------- Capability -------- */
    if (Cpk >= 1.33){
      blk += good(
        currentLang==="es"
          ? `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → Proceso capaz vs objetivo.`
          : `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → Capable vs target.`
      );
    }
    else if (Cpk >= 1.00){
      blk += warn(
        currentLang==="es"
          ? `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → Proceso borderline.`
          : `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → Borderline capability.`
      );
    }
    else{
      blk += bad(
        currentLang==="es"
          ? `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → Proceso NO capaz vs objetivo — enfocar aquí.`
          : `Cp=${Cp.toFixed(2)}, Cpk=${Cpk.toFixed(2)} → NOT capable vs target — focus here.`
      );
    }

    statsFocusDiv.innerHTML += `<div style="margin-bottom:12px;">${blk}</div>`;
  }
}
  function renderStatsDetail(){
    statsBody.innerHTML='';
    const groups = groupByProcess();
    const ctTarget = computeCtTargetSeconds();

    groups.forEach((arr,key)=>{
      const [proc,mode] = key.split('||');
      const st = calcStats(arr);
      if(!st) return;

      let cp='-', cpk='-';
      if(ctTarget && st.std>0){
        const USL = ctTarget;
        const LSL = 0;
        const cpv = (USL-LSL)/(6*st.std);
        const cpu = (USL-st.mean)/(3*st.std);
        const cpl = (st.mean-LSL)/(3*st.std);
        const cpkv = Math.min(cpu,cpl);
        cp  = cpv.toFixed(2);
        cpk = cpkv.toFixed(2);
      }

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${st.n}</td>
        <td>${formatSecs(st.mean)}</td>
        <td>${formatSecs(st.median)}</td>
        <td>${formatSecs(st.p10)}</td>
        <td>${formatSecs(st.p90)}</td>
        <td>${formatSecs(st.min)}</td>
        <td>${formatSecs(st.max)}</td>
        <td>${formatSecs(st.std)}</td>
        <td>${(st.cv*100).toFixed(1)}</td>
        <td>${cp}</td>
        <td>${cpk}</td>
      `;
      statsBody.appendChild(tr);
    });
  }

  function renderContractSummary(){
    const groups = groupByProcess();
    const eff = Math.min(Math.max(parseFloat(effInput.value)||100,10),100);
    const hours = Math.min(Math.max(parseFloat(hInput.value)||8,1),24);
    const days  = Math.min(Math.max(parseInt(dInput.value)||5,1),7);
    const pcd   = parseFloat(pcdInput.value)||0;
    const view  = capViewSel.value;
    contractSummary.innerHTML='';

    if(!groups.size){
      contractSummary.innerHTML = currentLang==='es'
        ? '<span style="color:var(--text-muted);">Sin datos todavía. Toma algunas vueltas para ver capacidad vs contrato.</span>'
        : '<span style="color:var(--text-muted);">No data yet. Take a few laps to see capacity vs contract.</span>';
      return;
    }

    const frag = document.createDocumentFragment();

    groups.forEach((arr,key)=>{
      const [proc,mode] = key.split('||');
      const st = calcStats(arr);
      if(!st) return;
      const ctMed = st.median;
      if(!ctMed) return;
      let perHour = 3600/ctMed;
      let cap100 = 0;
      if(view==='hour') cap100 = perHour;
      else if(view==='day') cap100 = perHour*hours;
      else cap100 = perHour*hours*days;

      const capEff = cap100*(eff/100);

      let contractUnits = 0;
      if(pcd>0){
        if(view==='hour') contractUnits = (pcd/hours)||0;
        else if(view==='day') contractUnits = pcd;
        else contractUnits = pcd*days;
      }

      let pct = contractUnits>0 ? (capEff/contractUnits*100) : 0;
      let tagClass='badge-warn';
      let label = currentLang==='es'
        ? 'Sin contrato cargado'
        : 'No contract loaded';
      if(contractUnits>0){
        if(pct<85){
          tagClass='badge-bad';
        }else if(pct<100){
          tagClass='badge-warn';
        }else{
          tagClass='badge-good';
        }
        label = currentLang==='es'
          ? `${pct.toFixed(0)}% vs contrato`
          : `${pct.toFixed(0)}% vs contract`;
      }

      const unitsLabel = currentLang==='es' ? 'unidades' : 'units';
      const div = document.createElement('div');
      div.style.marginBottom='4px';
      div.innerHTML = `
        <span style="font-weight:600;">${proc} (${mode})</span>
        – ${currentLang==='es' ? 'mediana de TC' : 'median CT'}
        <span style="font-weight:600;">${formatSecs(ctMed)} s</span>,
        ${currentLang==='es' ? 'capacidad @Eff' : 'capacity @Eff'} ≈
        <span style="font-weight:600;">${capEff?formatUnits(capEff):'-'} ${unitsLabel}/${view}</span>
        ${contractUnits>0?`<span class="badge ${tagClass}" style="margin-left:4px;">${label}</span>`:''}
      `;
      frag.appendChild(div);
    });

    contractSummary.appendChild(frag);
  }

  // SNAPSHOT de capacidad (líneas 1 y 2 debajo del resumen)
  function renderCapacitySnapshot(){
    if(!capacitySnapshotDiv) return;

    const groups = groupByProcess();
    const {proc,mode} = ensureDefaults();
    const key = proc + '||' + mode;
    const arr = groups.get(key);

    capacitySnapshotDiv.innerHTML = '';

    if(!arr || !arr.length){
      capacitySnapshotDiv.innerHTML =
        currentLang==='es'
          ? '<span style="color:var(--text-muted);">Sin snapshot de capacidad para el proceso actual. Toma algunas vueltas primero.</span>'
          : '<span style="color:var(--text-muted);">No capacity snapshot yet for current process. Take a few laps first.</span>';
      return;
    }

    const st = calcStats(arr);
    if(!st || !st.median){
      capacitySnapshotDiv.innerHTML =
        currentLang==='es'
          ? '<span style="color:var(--text-muted);">No hay suficiente información para estimar el snapshot de capacidad.</span>'
          : '<span style="color:var(--text-muted);">Not enough data to estimate capacity snapshot.</span>';
      return;
    }

    const eff   = Math.min(Math.max(parseFloat(effInput.value)||100,10),100);
    const hours = Math.min(Math.max(parseFloat(hInput.value)||8,1),24);
    const days  = Math.min(Math.max(parseInt(dInput.value)||5,1),7);
    const view  = capViewSel.value;

    // Actual (mediana)
    const ctMed = st.median;
    let perHourCurr = 3600/ctMed;
    let capCurr = 0;
    if(view === 'hour') capCurr = perHourCurr;
    else if(view === 'day') capCurr = perHourCurr*hours;
    else capCurr = perHourCurr*hours*days;
    const capCurrEff = capCurr*(eff/100);

    // Potencial usando P10 (mejor 10%)
    const ctPot = st.p10 && st.p10 > 0 ? st.p10 : ctMed;
    let perHourPot = 3600/ctPot;
    let capPot = 0;
    if(view === 'hour') capPot = perHourPot;
    else if(view === 'day') capPot = perHourPot*hours;
    else capPot = perHourPot*hours*days;
    const capPotEff = capPot*(eff/100);

    const gain = capPotEff - capCurrEff;
    const gainPct = capCurrEff > 0 ? (gain/capCurrEff*100) : 0;

    const effLabel = eff.toFixed(0) + '%';

    let gainHtml = '';
    if(gain > 0){
      const txt = currentLang==='es'
        ? `(+${formatUnits(gain)}; +${gainPct.toFixed(0)}%)`
        : `(+${formatUnits(gain)}; +${gainPct.toFixed(0)}%)`;
      gainHtml = `<span class="capacity-gain">${txt}</span>`;
    }else if(gain < 0){
      const txt = currentLang==='es'
        ? '(sin ganancia vs actual – P10 ≥ mediana)'
        : '(no gain vs current – P10 ≥ median)';
      gainHtml = ` <span style="color:var(--accent-amber);">${txt}</span>`;
    }

    const unitsLabel = currentLang==='es' ? 'unidades' : 'units';

    capacitySnapshotDiv.innerHTML = `
      <div class="snapshot-line">
        ${currentLang==='es'
          ? `1) Capacidad actual @Eff (${effLabel}) ≈ <strong>${capCurrEff ? formatUnits(capCurrEff) : '-'}</strong> ${unitsLabel}/${view}`
          : `1) Current capacity @Eff (${effLabel}) ≈ <strong>${capCurrEff ? formatUnits(capCurrEff) : '-'}</strong> ${unitsLabel}/${view}`
        }
      </div>
      <div class="snapshot-line">
        ${currentLang==='es'
          ? `2) Potencial (P10, misma Eff) ≈ <strong>${capPotEff ? formatUnits(capPotEff) : '-'}</strong> ${unitsLabel}/${view}`
          : `2) Potential (P10, same Eff) ≈ <strong>${capPotEff ? formatUnits(capPotEff) : '-'}</strong> ${unitsLabel}/${view}`
        }
        ${gainHtml}
      </div>
    `;
  }

  function renderStatsFocus(){
    statsFocusDiv.innerHTML='';
    const groups = groupByProcess();
    if(!groups.size){
      statsFocusDiv.innerHTML = currentLang==='es'
        ? '<div class="focus-line focus-warn">Sin muestras aún. Toma al menos 10–15 vueltas en el proceso cuello de botella.</div>'
        : '<div class="focus-line focus-warn">No samples yet. Take at least 10–15 laps on the bottleneck process.</div>';
      return;
    }

    const ctTarget = computeCtTargetSeconds();

    groups.forEach((arr,key)=>{
      const [proc,mode] = key.split('||');
      const st = calcStats(arr);
      if(!st) return;
      const n = st.n;
      const cv = st.cv;
      const mean = st.mean;
      const med = st.median;

      // tamaño de muestra recomendado según variación
      let recN;
      if(cv<=0.10) recN = 10;
      else if(cv<=0.20) recN = 15;
      else if(cv<=0.30) recN = 25;
      else recN = 40;

      const ratio = n/recN;
      let sampleClass='focus-warn';
      let sampleMsg;
      if(ratio<0.6){
        sampleClass='focus-bad';
        sampleMsg = currentLang==='es'
          ? `Tamaño de muestra: ${n} / ${recN} – muestra muy pequeña para ±3%; úsala solo como referencia.`
          : `Sample size: ${n} / ${recN} – sample too small for ±3%; use only as reference.`;
      }else if(ratio<0.9){
        sampleClass='focus-warn';
        sampleMsg = currentLang==='es'
          ? `Tamaño de muestra: ${n} / ${recN} – casi suficiente para ±3%; un par de vueltas más ayudarán.`
          : `Sample size: ${n} / ${recN} – almost enough for ±3%; a couple more laps would help.`;
      }else{
        sampleClass='focus-good';
        sampleMsg = currentLang==='es'
          ? `Tamaño de muestra: ${n} / ${recN} – suficiente para decisiones con objetivo ±3%.`
          : `Sample size: ${n} / ${recN} – enough for decisions at ±3% target.`;
      }

      // variación
      let varClass='focus-warn';
      let varMsg;
      if(cv<0.08){
        varClass='focus-good';
        varMsg = currentLang==='es'
          ? `Baja variación – el proceso se ve estable.`
          : `Low variation – process looks stable.`;
      }else if(cv>0.2){
        varClass='focus-bad';
        varMsg = currentLang==='es'
          ? `Alta variación – tiempos inestables.`
          : `High variation – unstable timings.`;
      }else{
        varMsg = currentLang==='es'
          ? 'Variación moderada.'
          : 'Moderate variation.';
      }

      // simetría / normalidad
      const diff = Math.abs(mean-med);
      let symClass='focus-good';
      let symMsg;
      if(diff>0.2*med){
        symClass='focus-warn';
        symMsg = currentLang==='es'
          ? 'Media y mediana alejadas – distribución no normal, revisa outliers o método.'
          : 'Mean and median are far – non-normal data, check outliers or method.';
      }else{
        symMsg = currentLang==='es'
          ? 'Media y mediana cercanas – distribución cercana a normal.'
          : 'Mean and median are close – distribution close to normal.';
      }

      // capacidad
      let capClass='focus-warn';
      let capMsg = currentLang==='es'
        ? 'Sin contrato cargado – no se evalúa capacidad vs objetivo.'
        : 'No contract loaded – capability vs target not evaluated.';
      if(ctTarget && st.std>0){
        const USL = ctTarget;
        const LSL = 0;
        const cpv = (USL-LSL)/(6*st.std);
        const cpu = (USL-st.mean)/(3*st.std);   // ← YA CORREGIDO
        const cpl = (st.mean-LSL)/(3*st.std);
        const cpkv = Math.min(cpu,cpl);
        if(cpkv<1.0){
          capClass='focus-bad';
          capMsg = currentLang==='es'
            ? `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Proceso NO capaz vs objetivo – enfocar aquí.`
            : `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Process not capable – focus here.`;
        }else if(cpkv<1.33){
          capClass='focus-warn';
          capMsg = currentLang==='es'
            ? `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Capacidad borderline – reduce variación.`
            : `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Borderline capability – reduce variation.`;
        }else{
          capClass='focus-good';
          capMsg = currentLang==='es'
            ? `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Proceso capaz vs objetivo.`
            : `Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → Process capable vs target.`;
        }
      }

      const block = document.createElement('div');
      block.style.marginBottom='6px';
      block.innerHTML = `
        <div style="font-weight:600;margin-bottom:2px;">${proc} (${mode})</div>
        <div class="focus-line ${sampleClass}">${sampleMsg}</div>
        <div class="focus-line ${varClass}">Std dev ≈ ${formatSecs(st.std)} s (${(cv*100).toFixed(1)}%).
          ${varMsg}</div>
        <div class="focus-line ${symClass}">
          ${currentLang==='es'
            ? `Media ≈ ${formatSecs(mean)} s, Mediana ≈ ${formatSecs(med)} s. ${symMsg}`
            : `Mean ≈ ${formatSecs(mean)} s, Median ≈ ${formatSecs(med)} s. ${symMsg}`
          }
        </div>
        <div class="focus-line ${capClass}">${capMsg}</div>
      `;
      statsFocusDiv.appendChild(block);
    });
  }
  // ===== Gráficas =====
  function updateChartOptions(){
    const groups = groupByProcess();
    const previous = chartSelect.value;
    chartSelect.innerHTML='';
    if(!groups.size){
      const opt = document.createElement('option');
      opt.value='';
      opt.textContent = currentLang==='es' ? 'Sin procesos aún' : 'No process yet';
      chartSelect.appendChild(opt);
      drawTimeSeries(null,null);
      drawHistogram(null,null);
      return;
    }
    let firstKey=null;
    groups.forEach((_,key)=>{
      if(!firstKey) firstKey=key;
      const opt = document.createElement('option');
      opt.value=key;
      const [p,m]=key.split('||');
      opt.textContent=`${p} (${m})`;
      chartSelect.appendChild(opt);
    });
    if(previous && groups.has(previous)){
      chartSelect.value=previous;
    }else{
      chartSelect.value=firstKey;
    }
    renderCharts();
  }

  function renderCharts(){
    const key = chartSelect.value;
    const groups = groupByProcess();
    if(!key || !groups.has(key)){
      drawTimeSeries(null,null);
      drawHistogram(null,null);
      return;
    }
    const arr = groups.get(key);
    const st  = calcStats(arr);
    drawTimeSeries(arr,st);
    drawHistogram(arr,st);
  }

  function drawTimeSeries(arr,st){
    const ctx = timeSeriesCanvas.getContext('2d');
    const w = timeSeriesCanvas.width;
    const h = timeSeriesCanvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#020b1a';
    ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st){
      ctx.fillStyle='#607d8b';
      ctx.font='12px system-ui';
      ctx.fillText(
        currentLang==='es'
          ? 'Se requieren al menos 3 muestras para la gráfica.'
          : 'Need at least 3 samples for chart.',
        10,20
      );
      return;
    }

    const vals = st.values;
    let min = st.min;
    let max = st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=35,padR=8,padT=10,padB=18;
    const innerW = w-padL-padR;
    const innerH = h-padT-padB;

    function yScale(v){
      return padT + innerH*(1-(v-min)/(max-min));
    }
    function xScale(i){
      if(vals.length===1) return padL+innerW/2;
      return padL + innerW*(i/(vals.length-1));
    }

    // grid horizontal
    ctx.strokeStyle='rgba(255,255,255,0.08)';
    ctx.lineWidth=1;
    ctx.beginPath();
    for(let g=0;g<=4;g++){
      const y = padT + innerH*g/4;
      ctx.moveTo(padL,y);
      ctx.lineTo(w-padR,y);
    }
    ctx.stroke();

    // eje
    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,h-padB);
    ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    // labels Y
    ctx.fillStyle='#90a4ae';
    ctx.font='10px system-ui';
    for(let g=0;g<=4;g++){
      const val = min + (max-min)*g/4;
      const y = padT + innerH*(1-g/4);
      ctx.fillText(formatSecs(val),2,y+3);
    }

    // línea datos
    ctx.strokeStyle='#29b6f6';
    ctx.lineWidth=2;
    ctx.beginPath();
    vals.forEach((v,i)=>{
      const x=xScale(i),y=yScale(v);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // puntos
    ctx.fillStyle='#29b6f6';
    vals.forEach((v,i)=>{
      const x=xScale(i),y=yScale(v);
      ctx.beginPath();
      ctx.arc(x,y,2.2,0,Math.PI*2);
      ctx.fill();
    });

    // mean, median, ±3σ
    ctx.setLineDash([4,3]);
    if(st.std>0){
      const ucl = st.mean+3*st.std;
      const lcl = st.mean-3*st.std;
      ctx.strokeStyle='rgba(255,82,82,0.9)';
      ctx.beginPath();
      ctx.moveTo(padL,yScale(ucl));
      ctx.lineTo(w-padR,yScale(ucl));
      ctx.moveTo(padL,yScale(lcl));
      ctx.lineTo(w-padR,yScale(lcl));
      ctx.stroke();
    }
    // mean
    ctx.strokeStyle='rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(padL,yScale(st.mean));
    ctx.lineTo(w-padR,yScale(st.mean));
    ctx.stroke();
    // median
    ctx.strokeStyle='rgba(0,230,118,0.9)';
    ctx.beginPath();
    ctx.moveTo(padL,yScale(st.median));
    ctx.lineTo(w-padR,yScale(st.median));
    ctx.stroke();
    ctx.setLineDash([]);

    const meanLabel   = currentLang==='es' ? 'Media'   : 'Mean';
    const medianLabel = currentLang==='es' ? 'Mediana' : 'Median';

    ctx.fillStyle='#cfd8dc';
    ctx.font='10px system-ui';
    ctx.fillText(meanLabel, w-padR-34,yScale(st.mean)-2);
    ctx.fillStyle='#00e676';
    ctx.fillText(medianLabel, w-padR-52,yScale(st.median)-2);
  }

  function drawHistogram(arr,st){
    const ctx = histCanvas.getContext('2d');
    const w = histCanvas.width;
    const h = histCanvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#020b1a';
    ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st){
      ctx.fillStyle='#607d8b';
      ctx.font='12px system-ui';
      ctx.fillText(
        currentLang==='es'
          ? 'Se requieren más muestras para el histograma.'
          : 'Need more samples for histogram.',
        10,20
      );
      return;
    }

    const vals = st.values;
    let min = st.min;
    let max = st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=30,padR=8,padT=8,padB=20;
    const innerW = w-padL-padR;
    const innerH = h-padT-padB;
    const binsCount = 8;
    const binSize = (max-min)/binsCount;
    const bins = new Array(binsCount).fill(0);
    vals.forEach(v=>{
      let idx = Math.floor((v-min)/binSize);
      if(idx===binsCount) idx=binsCount-1;
      bins[idx]++;
    });
    const maxBin = Math.max(...bins);

    // ejes
    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,h-padB);
    ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    // barras
    const barW = innerW/binsCount;
    ctx.fillStyle='#29b6f6';
    bins.forEach((c,i)=>{
      const x = padL + i*barW + 1;
      const barH = maxBin? innerH*(c/maxBin) : 0;
      const y = (h-padB) - barH;
      ctx.fillRect(x,y,barW-2,barH);
    });

    // curva normal teórica
    if(st.std>0){
      const points = 80;
      let maxPdf=0;
      const pdfVals=[];
      for(let i=0;i<points;i++){
        const xVal = min + (max-min)*i/(points-1);
        const z = (xVal-st.mean)/st.std;
        const pdf = Math.exp(-0.5*z*z);
        pdfVals.push({xVal,pdf});
        if(pdf>maxPdf) maxPdf=pdf;
      }
      ctx.strokeStyle='rgba(255,241,118,0.9)';
      ctx.lineWidth=1.5;
      ctx.beginPath();
      pdfVals.forEach((p,i)=>{
        const x = padL + innerW*( (p.xVal-min)/(max-min) );
        const y = (h-padB) - innerH*(p.pdf/maxPdf);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    // labels X
    ctx.fillStyle='#90a4ae';
    ctx.font='10px system-ui';
    ctx.fillText(formatSecs(min),padL, h-8);
    ctx.fillText(formatSecs(max), w-padR-32, h-8);
    ctx.fillText(formatSecs(st.median), padL+innerW/2-16, h-8);

    // median
    const medX = padL + innerW*( (st.median-min)/(max-min) );
    ctx.strokeStyle='#00e676';
    ctx.beginPath();
    ctx.moveTo(medX,padT);
    ctx.lineTo(medX,h-padB);
    ctx.stroke();

    // P10 / P90
    const p10x = padL + innerW*( (st.p10-min)/(max-min) );
    const p90x = padL + innerW*( (st.p90-min)/(max-min) );
    ctx.strokeStyle='rgba(255,241,118,0.9)';
    ctx.beginPath();
    ctx.moveTo(p10x,padT);
    ctx.lineTo(p10x,h-padB);
    ctx.moveTo(p90x,padT);
    ctx.lineTo(p90x,h-padB);
    ctx.stroke();
  }
  async function copyToClipboard(text){
    if(!text) return;
    try{
      await navigator.clipboard.writeText(text);
      alert(currentLang==='es' ? 'Copiado.' : 'Copied.');
    }catch(e){
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{
        document.execCommand('copy');
        alert(currentLang==='es' ? 'Copiado.' : 'Copied.');
      }catch(err){
        alert(
          currentLang==='es'
            ? 'Portapapeles no disponible. Puedes seleccionar y copiar manualmente.'
            : 'Clipboard not available. You can long-press and copy manually.'
        );
      }
      document.body.removeChild(ta);
    }
  }

  btnCopyAll.addEventListener('click',()=>{
    if(!laps.length){
      alert(currentLang==='es' ? 'No hay datos para copiar.' : 'No data to copy.');
      return;
    }
    const headerEn = ['#','Process','Mode','Status','Note','T1 (s)','T2 (s)','Total (s)'];
    const headerEs = ['#','Proceso','Modo','Estatus','Nota','T1 (s)','T2 (s)','Total (s)'];
    const header = currentLang==='es' ? headerEs : headerEn;

    const rows = laps.map((l,i)=>[
      i+1,
      l.process,
      l.mode,
      l.status||'',
      l.note||'',
      formatSecs(l.t1),
      formatSecs(l.t2),
      formatSecs(l.total)
    ].join('\t'));
    copyToClipboard(header.join('\t')+'\n'+rows.join('\n'));
  });

  function buildFullSummaryText(){
    const groups = groupByProcess();
    if(!groups.size) return '';

    const eff   = Math.min(Math.max(parseFloat(effInput.value)||100,10),100);
    const hours = Math.min(Math.max(parseFloat(hInput.value)||8,1),24);
    const days  = Math.min(Math.max(parseInt(dInput.value)||5,1),7);
    const pcd   = parseFloat(pcdInput.value)||0;
    const view  = capViewSel.value;
    const ctTarget = computeCtTargetSeconds();

    const lines = [];
    lines.push('TAKTLAB SUMMARY');
    lines.push('');

    // Capacity snapshot for current process
    const {proc: curProc, mode: curMode} = ensureDefaults();
    const keySnap = curProc + '||' + curMode;
    const snapGroups = groupByProcess();
    const arrSnap = snapGroups.get(keySnap);
    if(arrSnap && arrSnap.length){
      const stSnap = calcStats(arrSnap);
      if(stSnap && stSnap.median){
        const ctMedS = stSnap.median;
        let perHourCurr = 3600/ctMedS;
        let capCurr = 0;
        if(view === 'hour') capCurr = perHourCurr;
        else if(view === 'day') capCurr = perHourCurr*hours;
        else capCurr = perHourCurr*hours*days;
        const capCurrEff = capCurr*(eff/100);

        const ctPotS = stSnap.p10 && stSnap.p10>0 ? stSnap.p10 : ctMedS;
        let perHourPot = 3600/ctPotS;
        let capPot = 0;
        if(view === 'hour') capPot = perHourPot;
        else if(view === 'day') capPot = perHourPot*hours;
        else capPot = perHourPot*hours*days;
        const capPotEff = capPot*(eff/100);

        const gain = capPotEff - capCurrEff;
        const gainPct = capCurrEff>0 ? (gain/capCurrEff*100) : 0;

        lines.push(`CAPACITY SNAPSHOT – ${curProc} (${curMode})`);
        lines.push(
          `1) Current capacity @Eff (${eff.toFixed(0)}%) ≈ ${capCurrEff ? formatUnits(capCurrEff) : '-'} units/${view}`
        );
        if(capPotEff){
          lines.push(
            `2) Potential (P10, same Eff) ≈ ${formatUnits(capPotEff)} units/${view}` +
            (gain>0 ? `  [gain ≈ +${formatUnits(gain)}; +${gainPct.toFixed(0)}%]` : '')
          );
        }
        lines.push('');
      }
    }

    // Overview
    lines.push('PROCESS CAPACITY OVERVIEW');
    lines.push('Process\tMode\tN\tCTmed(s)\tCap100\tCap@Eff\t% vs contract');
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;
      const ctMed=st.median;
      let cap100=0;
      if(ctMed>0){
        const perHour=3600/ctMed;
        if(view==='hour') cap100=perHour;
        else if(view==='day') cap100=perHour*hours;
        else cap100=perHour*hours*days;
      }
      const capEff=cap100*(eff/100);
      let contractUnits=0;
      if(pcd>0){
        if(view==='hour') contractUnits=(pcd/hours)||0;
        else if(view==='day') contractUnits=pcd;
        else contractUnits=pcd*days;
      }
      let pctVs = contractUnits>0 ? (capEff/contractUnits*100) : NaN;
      lines.push(
        `${proc}\t${mode}\t${st.n}\t${formatSecs(ctMed)}\t${cap100?formatUnits(cap100):'-'}\t${capEff?formatUnits(capEff):'-'}\t${isFinite(pctVs)?pctVs.toFixed(0)+'%':''}`
      );
    });

    lines.push('');
    // Statistical detail
    lines.push('STATISTICAL DETAIL');
    lines.push('Process\tMode\tN\tMean(s)\tMedian(s)\tP10\tP90\tMin\tMax\tStd\tCV%\tCp\tCpk');
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;
      let cp='-',cpk='-';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-st.mean)/(3*st.std);
        const cpl=(st.mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        cp = cpv.toFixed(2);
        cpk = cpkv.toFixed(2);
      }
      lines.push(
        `${proc}\t${mode}\t${st.n}\t${formatSecs(st.mean)}\t${formatSecs(st.median)}\t${formatSecs(st.p10)}\t${formatSecs(st.p90)}\t${formatSecs(st.min)}\t${formatSecs(st.max)}\t${formatSecs(st.std)}\t${(st.cv*100).toFixed(1)}\t${cp}\t${cpk}`
      );
    });

    lines.push('');
    // Contract vs capacity summary
    lines.push('CONTRACT VS CAPACITY SUMMARY');
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;
      const ctMed=st.median;
      if(!ctMed) return;
      let perHour=3600/ctMed;
      let cap100=0;
      if(view==='hour') cap100=perHour;
      else if(view==='day') cap100=perHour*hours;
      else cap100=perHour*hours*days;
      const capEff=cap100*(eff/100);

      let contractUnits=0;
      if(pcd>0){
        if(view==='hour') contractUnits=(pcd/hours)||0;
        else if(view==='day') contractUnits=pcd;
        else contractUnits=pcd*days;
      }
      let pct=contractUnits>0?(capEff/contractUnits*100):NaN;
      let msg='No contract loaded';
      if(contractUnits>0){
        msg=`${pct.toFixed(0)}% vs contract`;
      }
      lines.push(
        `${proc} (${mode}) – median CT ${formatSecs(ctMed)} s, capacity@Eff ${capEff?formatUnits(capEff):'-'} units/${view} – ${msg}`
      );
    });

    lines.push('');
    // Stats focus (simple messages)
    lines.push('STATS FOCUS (SIMPLE MESSAGES)');
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;
      const n=st.n, cv=st.cv, mean=st.mean, med=st.median;

      let recN;
      if(cv<=0.10) recN=10;
      else if(cv<=0.20) recN=15;
      else if(cv<=0.30) recN=25;
      else recN=40;

      const ratio=n/recN;
      let sampleMsg;
      if(ratio<0.6) sampleMsg=`Sample size ${n}/${recN}: too small for ±3%; use only as reference.`;
      else if(ratio<0.9) sampleMsg=`Sample size ${n}/${recN}: almost enough for ±3%; a couple more laps help.`;
      else sampleMsg=`Sample size ${n}/${recN}: enough for decisions at ±3% target.`;

      let varMsg;
      if(cv<0.08) varMsg=`Low std (${formatSecs(st.std)} s, ${(cv*100).toFixed(1)}%): stable process.`;
      else if(cv>0.2) varMsg=`High std (${formatSecs(st.std)} s, ${(cv*100).toFixed(1)}%): unstable timings.`;
      else varMsg=`Moderate std (${formatSecs(st.std)} s, ${(cv*100).toFixed(1)}%).`;

      const diff=Math.abs(mean-med);
      let symMsg;
      if(diff>0.2*med) symMsg=`Mean ${formatSecs(mean)} vs median ${formatSecs(med)}: non-normal, check outliers.`;
      else symMsg=`Mean ${formatSecs(mean)} ~ median ${formatSecs(med)}: close to normal.`;

      let capMsg='No contract loaded – capability not evaluated.';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-mean)/(3*st.std);
        const cpl=(mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        if(cpkv<1.0) capMsg=`Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → process NOT capable – focus here.`;
        else if(cpkv<1.33) capMsg=`Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → borderline – reduce variation.`;
        else capMsg=`Cp=${cpv.toFixed(2)}, Cpk=${cpkv.toFixed(2)} → process capable vs target.`;
      }

      lines.push(`${proc} (${mode})`);
      lines.push(`  - ${sampleMsg}`);
      lines.push(`  - ${varMsg}`);
      lines.push(`  - ${symMsg}`);
      lines.push(`  - ${capMsg}`);
    });

    return lines.join('\n');
  }

  btnCopySum.addEventListener('click',()=>{
    const txt = buildFullSummaryText();
    if(!txt){
      alert(currentLang==='es' ? 'No hay resumen para copiar.' : 'No summary to copy.');
      return;
    }
    copyToClipboard(txt);
  });

  function renderAll(){
    renderDataTable();
    renderOverview();
    renderStatsDetail();
    renderContractSummary();
    renderCapacitySnapshot();
    renderStatsFocus();
    updateChartOptions();
    updateSampleInfo();
  }

  chartSelect.addEventListener('change',renderCharts);
  effInput.addEventListener('change',renderAll);
  pcdInput.addEventListener('change',renderAll);
  hInput.addEventListener('change',renderAll);
  dInput.addEventListener('change',renderAll);
  capViewSel.addEventListener('change',renderAll);

  // init
  updateDisplay();
  refreshRingStates();
  setLanguage(currentLang); // aplica EN/ES y hace renderAll
})();
</script>
</body>
</html>
